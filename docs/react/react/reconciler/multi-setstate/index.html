<!doctype html>
<html class="docs-version-current" lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.6">
<link rel="alternate" type="application/rss+xml" href="/ReactNote/blog/rss.xml" title="React Note Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/ReactNote/blog/atom.xml" title="React Note Blog Atom Feed"><title data-react-helmet="true">React Note</title><meta data-react-helmet="true" property="og:title" content="React Note"><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://BUPTlhuanyu.github.io/ReactNote/docs/react/react/reconciler/multi-setstate"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" name="description" content="概述，背景"><meta data-react-helmet="true" property="og:description" content="概述，背景"><link data-react-helmet="true" rel="shortcut icon" href="/ReactNote/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://BUPTlhuanyu.github.io/ReactNote/docs/react/react/reconciler/multi-setstate"><link data-react-helmet="true" rel="alternate" href="https://BUPTlhuanyu.github.io/ReactNote/docs/react/react/reconciler/multi-setstate" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://BUPTlhuanyu.github.io/ReactNote/docs/react/react/reconciler/multi-setstate" hreflang="x-default"><link rel="stylesheet" href="/ReactNote/assets/css/styles.2a5b91fc.css">
<link rel="preload" href="/ReactNote/assets/js/runtime~main.ee2f40a8.js" as="script">
<link rel="preload" href="/ReactNote/assets/js/main.33abd88d.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/ReactNote/"><img src="/ReactNote/img/logo.png" alt="React Note Logo" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/ReactNote/img/logo.png" alt="React Note Logo" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"><b class="navbar__title">React Note</b></a><a class="navbar__item navbar__link navbar__link--active" href="/ReactNote/docs/react/react/intro">React</a><a class="navbar__item navbar__link" href="/ReactNote/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/BUPTlhuanyu" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="react-toggle toggle_3Zt9 react-toggle--disabled"><div class="react-toggle-track" role="button" tabindex="-1"><div class="react-toggle-track-check"><span class="toggle_71bT">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_71bT">🌞</span></div><div class="react-toggle-thumb"></div></div><input type="checkbox" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper docs-doc-page"><div class="docPage_31aa"><button class="clean-btn backToTopButton_35hR" type="button"><svg viewBox="0 0 24 24" width="28"><path d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z" fill="currentColor"></path></svg></button><aside class="docSidebarContainer_3Kbt"><div class="sidebar_15mo"><nav class="menu thin-scrollbar menu_Bmed menuWithAnnouncementBar_2WvA"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#">react</a><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/ReactNote/docs/react/react/intro">介绍</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/ReactNote/docs/react/react/react">目录结构</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/ReactNote/docs/react/react/shared">公共方法</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="0">ReactElement</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="0">scheduler</a></li><li class="theme-doc-sidebar-item-category menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#" tabindex="0">reconciler</a><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/ReactNote/docs/react/react/reconciler/container-root">创建container对应的root</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/ReactNote/docs/react/react/reconciler/fiber-tree-root">创建root下的fiber树并开始初始调度</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/ReactNote/docs/react/react/reconciler/schedulework">创建root下的fiber树并开始初始调度</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/ReactNote/docs/react/react/reconciler/sync-async-work">同步与异步调度</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/ReactNote/docs/react/react/reconciler/performwork">调度的入口函数</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/ReactNote/docs/react/react/reconciler/performwork-on-root">从根节点开始调度</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/ReactNote/docs/react/react/reconciler/expiration-time">到期时间</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/ReactNote/docs/react/react/reconciler/multi-setstate">多次执行setState的更新机制</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/ReactNote/docs/react/react/reconciler/react-fiber-lazy-component">ReactFiberLazyComponent</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/ReactNote/docs/react/react/reconciler/todo-list">待整理流程</a></li></ul></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="0">event</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/ReactNote/docs/react/react/error/error-handle">如何处理错误</a></li></ul></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">react-hook-form</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">react-router</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">react-transition</a></li></ul></nav></div></aside><main class="docMainContainer_3ufF"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_3FnS"><div class="docItemContainer_33ec"><article><div class="theme-doc-markdown markdown"><header><h1></h1></header><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_31ik" id="概述背景"></a>概述，背景<a class="hash-link" href="#概述背景" title="Direct link to heading">#</a></h4><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">state初始值为{a:1}</span></span><span class="token-line" style="color:#393A34"><span class="token plain">问题1：最终state会是多少</span></span><span class="token-line" style="color:#393A34"><span class="token plain">clickHandler(){</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.setState({</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        a : 2</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    })</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.setState({</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        a : 3</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    })</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.setState({</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        a : 4</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    })</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.setState({</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        a : 5</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    })</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">问题2：最终state会是多少</span></span><span class="token-line" style="color:#393A34"><span class="token plain">clickHandler(){</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.setState((prevState, nextProps) =&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      return {a:prevState.a + 1};</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    })</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.setState((prevState, nextProps) =&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      return {a:prevState.a + 1};</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    })</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.setState((prevState, nextProps) =&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      return {a:prevState.a + 1};</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    })</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.setState((prevState, nextProps) =&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      return {a:prevState.a + 1};</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    })</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>注意本文将与之前的文章<a href="http://note.youdao.com/noteshare?id=84df98e9c1e5cb9d1a66864b34268a7f&amp;sub=1E16F316E66348EB945206AE4746119A" target="_blank" rel="noopener noreferrer">2-6-2、对类组件执行updateClassComponent</a>紧密相关。</p><p><strong>阅读本文需要特别关注的是</strong>：</p><ol><li>如下多个setState同步的执行的时候，更新任务的到期时间是相同的</li></ol><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">原因：同一事件中多次同步执行setState的到期时间都是相同的</span></span><span class="token-line" style="color:#393A34"><span class="token plain">There&#x27;s already pending work. We might be in the middle of a browser</span></span><span class="token-line" style="color:#393A34"><span class="token plain">event. If we were to read the current time, it could cause multiple updates</span></span><span class="token-line" style="color:#393A34"><span class="token plain">within the same event to receive different expiration times, leading to</span></span><span class="token-line" style="color:#393A34"><span class="token plain">tearing. Return the last read time. During the next idle callback, the</span></span><span class="token-line" style="color:#393A34"><span class="token plain">time will be updated</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ol start="2"><li>当前fiber的到期时间expirationTime会被设置为与类组件setState产生的更新任务相同的到期时间</li></ol><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_31ik" id="必要的回顾与准备"></a>必要的回顾与准备<a class="hash-link" href="#必要的回顾与准备" title="Direct link to heading">#</a></h4><p>回顾类组件的实例化，给出一些setState相关的准备工作。</p><blockquote><p>在执行ReactDOM.render构建fiber树的时候，遇到类类型的组件，会调用updateClassComponent，该函数会在组件挂载生命周期中调用constructClassInstance实例化类类型组件。</p></blockquote><p>updateClassComponent所在路径：react\packages\react-reconciler\src\ReactFiberBeginWork.js</p><blockquote><p>constructClassInstance构建类组件的实例然后调用adoptClassInstance(workInProgress, instance)给传入的instance添加更新器updater属性值为classComponentUpdater，这个classComponentUpdater在该文件中是一个包含多个属性的 对象，主要用于存放更新任务相关逻辑</p></blockquote><p>constructClassInstance函数所在路径：react\packages\react-reconciler\src\ReactFiberClassComponent.js
。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">const classComponentUpdater = {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  isMounted,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  enqueueSetState(inst, payload, callback) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      ...</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  },</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  enqueueReplaceState(inst, payload, callback) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      ...</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  },</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  enqueueForceUpdate(inst, callback) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     ...</span></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>setState是依赖enqueueSetState来执行更新的,enqueueSetState代码在下面的分析中会给出。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_31ik" id="从setstate方法切入"></a>从setState方法切入<a class="hash-link" href="#从setstate方法切入" title="Direct link to heading">#</a></h4><p>setState方法：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">Component.prototype.setState = function(partialState, callback) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    ...</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  this.updater.enqueueSetState(this, partialState, callback, &#x27;setState&#x27;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>在上述方法中，必须要介绍一下参数代表的意义：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">partialState：传入setState方法的新的state对象</span></span><span class="token-line" style="color:#393A34"><span class="token plain">callback：state更新之后的回调函数</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>在类组价中调用setState会直接调用实例上updater的enqueueSetState方法，其代码如下：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">enqueueSetState(inst, payload, callback) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  //获取实例对应的fiber</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  const fiber = ReactInstanceMap.get(inst);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  //计算当前时间:react确保了在同一个时间中所有的更新都是相同的到期时间</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  const currentTime = requestCurrentTime();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  //根据当前时间与fiber计算到期时间</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  const expirationTime = computeExpirationForFiber(currentTime, fiber);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  //传入一个到期时间，返回一个对象，见packages\react-reconciler\src\ReactUpdateQueue.js</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  const update = createUpdate(expirationTime);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  //利用新的state修改update.payload</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  update.payload = payload;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  //利用callback修改update.callback</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  if (callback !== undefined &amp;&amp; callback !== null) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (__DEV__) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      warnOnInvalidCallback(callback, &#x27;setState&#x27;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    update.callback = callback;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  //？？？存疑，调用scheduler删除当前某个任务，这里先不讨论</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  flushPassiveEffects();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  //开始调度setState带来的更新</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  enqueueUpdate(fiber, update);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  //开始调度新的当前fiber子树，设置相关的到期时间等等,这里关键是会给当前fiber设置expirationTime为setState的更新任务相同的值</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  scheduleWork(fiber, expirationTime);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_31ik" id="enqueueupdate"></a>enqueueUpdate<a class="hash-link" href="#enqueueupdate" title="Direct link to heading">#</a></h4><blockquote><p>enqueueUpdate为fiber构建updateQueue队列，多个setState的效果是多个具备相同到期时间的update都被添加到队列中</p></blockquote><p>依赖的函数：</p><ul><li>createUpdateQueue返回一个UpdateQueue类型的对象（该对象是由update组成的队列），传入的state存放到baseState属性上。</li><li>appendUpdateToQueue将传入的update添加到传入的update队列即queue的最后。</li><li>cloneUpdateQueue返回传入的update队列的克隆版，返回的队列与传入的队列的firstUpdate指向同一个对象，lastUpdate也指向同一个对象。</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">export function createUpdateQueue&lt;State&gt;(baseState: State): UpdateQueue&lt;State&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  const queue: UpdateQueue&lt;State&gt; = {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    baseState,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    firstUpdate: null,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    lastUpdate: null,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    firstCapturedUpdate: null,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    lastCapturedUpdate: null,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    firstEffect: null,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    lastEffect: null,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    firstCapturedEffect: null,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    lastCapturedEffect: null,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  };</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  return queue;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">function appendUpdateToQueue&lt;State&gt;(</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  queue: UpdateQueue&lt;State&gt;,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  update: Update&lt;State&gt;,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  // Append the update to the end of the list.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  if (queue.lastUpdate === null) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // Queue is empty</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    queue.firstUpdate = queue.lastUpdate = update;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  } else {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    queue.lastUpdate.next = update;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    queue.lastUpdate = update;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">function cloneUpdateQueue&lt;State&gt;(</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  currentQueue: UpdateQueue&lt;State&gt;,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">): UpdateQueue&lt;State&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  const queue: UpdateQueue&lt;State&gt; = {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    baseState: currentQueue.baseState,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    firstUpdate: currentQueue.firstUpdate,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    lastUpdate: currentQueue.lastUpdate,</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // TODO: With resuming, if we bail out and resuse the child tree, we should</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // keep these effects.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    firstCapturedUpdate: null,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    lastCapturedUpdate: null,</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    firstEffect: null,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    lastEffect: null,</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    firstCapturedEffect: null,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    lastCapturedEffect: null,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  };</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  return queue;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>enqueueUpdate的作用是将传入的更新任务（包含新state以及到期时间的对象）添加到更新队列。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">export function enqueueUpdate&lt;State&gt;(fiber: Fiber, update: Update&lt;State&gt;) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  // Update queues are created lazily.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 使用alternate属性双向连接一个当前fiber和其work-in-progress，当前fiber实例的alternate属性指向其work-in-progress，work-in-progress的alternate属性指向当前稳定fiber。</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  const alternate = fiber.alternate;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  let queue1;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  let queue2;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  if (alternate === null) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // There&#x27;s only one fiber.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    queue1 = fiber.updateQueue;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    queue2 = null;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (queue1 === null) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      //如果当前组件没有等待setState的队列则创建一个，</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 利用fiber当前已经记录并需要整合的state存储到queue1与fiber.updateQueue</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      queue1 = fiber.updateQueue = createUpdateQueue(fiber.memoizedState);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  } else {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // There are two owners.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 如果fiber树以及workinprogress树都存在，下面的逻辑则会同步两个树的update队列</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    queue1 = fiber.updateQueue;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    queue2 = alternate.updateQueue;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 当两个树的队列至少有一个不存在的时候执行队列创建或者复制操作</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (queue1 === null) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      if (queue2 === null) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Neither fiber has an update queue. Create new ones.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        //  两个队列都没有则根据各自的memoizedState创建update队列</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        queue1 = fiber.updateQueue = createUpdateQueue(fiber.memoizedState);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        queue2 = alternate.updateQueue = createUpdateQueue(</span></span><span class="token-line" style="color:#393A34"><span class="token plain">          alternate.memoizedState,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        );</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      } else {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 如果有一个没有则复制另一个队列给它</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Only one fiber has an update queue. Clone to create a new one.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        queue1 = fiber.updateQueue = cloneUpdateQueue(queue2);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      if (queue2 === null) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 如果有一个没有则复制另一个队列给它</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Only one fiber has an update queue. Clone to create a new one.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        queue2 = alternate.updateQueue = cloneUpdateQueue(queue1);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      } else {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Both owners have an update queue.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  if (queue2 === null || queue1 === queue2) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // There&#x27;s only a single queue.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 如果只有一个树，或者两棵树队列是同一个，则将传入的更新对象添加到第一个队列中</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    appendUpdateToQueue(queue1, update);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  } else {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // There are two queues. We need to append the update to both queues,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // while accounting for the persistent structure of the list — we don&#x27;t</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // want the same update to be added multiple times.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    //  如果两个队列存在，则将更新任务加入两个队列中，并避免被添加多次</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (queue1.lastUpdate === null || queue2.lastUpdate === null) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      // One of the queues is not empty. We must add the update to both queues.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      //  有一个队列不为空，将update添加到两个队列</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      appendUpdateToQueue(queue1, update);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      appendUpdateToQueue(queue2, update);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      // Both queues are non-empty. The last update is the same in both lists,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      // because of structural sharing. So, only append to one of the lists.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      appendUpdateToQueue(queue1, update);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      // But we still need to update the `lastUpdate` pointer of queue2.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      queue2.lastUpdate = update;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_31ik" id="processupdatequeue"></a>processUpdateQueue<a class="hash-link" href="#processupdatequeue" title="Direct link to heading">#</a></h4><p>通过多个同步执行的setState函数的作用，为fiber生成了对应的updateQueue，并且updateQueue中的每个update的到期时间是相同的。最终在调度更新树的时候会调用performWork，其中会调用updateClassInstance，其中会调用processUpdateQueue函数来处理之前构建的updateQueue。只考虑updateQueue中的update，省略CapturedUpdate相关逻辑之后processUpdateQueue部分代码如下：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">export function processUpdateQueue&lt;State&gt;(</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  workInProgress: Fiber,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  queue: UpdateQueue&lt;State&gt;,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  props: any,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  instance: any,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  renderExpirationTime: ExpirationTime,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">): void {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  hasForceUpdate = false;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  queue = ensureWorkInProgressQueueIsAClone(workInProgress, queue);</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  // These values may change as we process the queue.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  let newBaseState = queue.baseState;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  let newFirstUpdate = null;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  let newExpirationTime = NoWork;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  // Iterate through the list of updates to compute the result.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  let update = queue.firstUpdate;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  let resultState = newBaseState;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  while (update !== null) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    const updateExpirationTime = update.expirationTime;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (updateExpirationTime &lt; renderExpirationTime) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      // This update does not have sufficient priority. Skip it.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      if (newFirstUpdate === null) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // This is the first skipped update. It will be the first update in</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // the new list.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        newFirstUpdate = update;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Since this is the first update that was skipped, the current result</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // is the new base state.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        newBaseState = resultState;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      // Since this update will remain in the list, update the remaining</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      // expiration time.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      if (newExpirationTime &lt; updateExpirationTime) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        newExpirationTime = updateExpirationTime;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      // This update does have sufficient priority. Process it and compute</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      // a new result.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      resultState = getStateFromUpdate(</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        workInProgress,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        queue,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        update,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        resultState,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        props,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        instance,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      );</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      const callback = update.callback;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      if (callback !== null) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        workInProgress.effectTag |= Callback;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Set this to null, in case it was mutated during an aborted render.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        update.nextEffect = null;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (queue.lastEffect === null) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">          queue.firstEffect = queue.lastEffect = update;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">          queue.lastEffect.nextEffect = update;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">          queue.lastEffect = update;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // Continue to the next update.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    update = update.next;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  if (newFirstUpdate === null) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    queue.lastUpdate = null;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  if (newFirstUpdate === null &amp;&amp; newFirstCapturedUpdate === null) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // We processed every update, without skipping. That means the new base</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // state is the same as the result state.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    newBaseState = resultState;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  queue.baseState = newBaseState;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  queue.firstUpdate = newFirstUpdate;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  workInProgress.expirationTime = newExpirationTime;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  workInProgress.memoizedState = resultState;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>在同步多次执行setState的情况下，循环中的 if 判断条件newExpirationTime始终会等于renderExpirationTime，因此会循环遍历updateQueue队列中的update，并调用getStateFromUpdate不断修改合并state，得到最终的state即resultState。processUpdateQueue的最后会将得到的新的state存储到queue.baseState，将queue.firstUpdate置为null。</p><p>接下来通过getStateFromUpdate看如何合并state：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">function getStateFromUpdate&lt;State&gt;(</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  workInProgress: Fiber,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  queue: UpdateQueue&lt;State&gt;,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  update: Update&lt;State&gt;,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  prevState: State,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  nextProps: any,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  instance: any,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">): any {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  switch (update.tag) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     ...</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // Intentional fallthrough</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    case UpdateState: {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      const payload = update.payload;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      let partialState;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      //两种不同的setState方式：第一个参数是一个对象或者一个函数</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      if (typeof payload === &#x27;function&#x27;) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Updater function</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        partialState = payload.call(instance, prevState, nextProps);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      } else {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Partial state object</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        partialState = payload;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      if (partialState === null || partialState === undefined) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Null and undefined are treated as no-ops.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 如果合并后的state为null或者undefined则返回之前的state</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return prevState;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      // Merge the partial state and the previous state.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      // 合并state，并返回，Object.assign这里是第一层深拷贝，如果state比较复杂，就会存在深层属性浅拷贝的现象</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      return Object.assign({}, prevState, partialState);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    ...</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  return prevState;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>由于这里只看setState，因此省略了部分代码。这里可以很清晰的看到state的合并机制，setState的第一个参数有两种方式：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">1、对象形式</span></span><span class="token-line" style="color:#393A34"><span class="token plain">2、函数形式</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    (prevState, nextProps) =&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      return {...};</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li>对象形式：会直接将当前的setState中的新的state作为partialState，然后利用Object.assign({}, prevState, partialState)将上一次setState之后的state与当前的新的state合并到一个新的对象上。</li><li>函数形式：利用该函数对上一次setState之后的state与下一次的props进行计算后返回的对象作为当前新的state，并存储在partialState，最后与prevState合并到新的对象上。</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_31ik" id="下面代码state最终会是5"></a>下面代码state最终会是5：<a class="hash-link" href="#下面代码state最终会是5" title="Direct link to heading">#</a></h4><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">state初始值为{a:1}</span></span><span class="token-line" style="color:#393A34"><span class="token plain">clickHandler(){</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.setState((prevState, nextProps) =&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      return {a:prevState.a + 1};</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    })</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.setState((prevState, nextProps) =&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      return {a:prevState.a + 1};</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    })</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.setState((prevState, nextProps) =&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      return {a:prevState.a + 1};</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    })</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.setState((prevState, nextProps) =&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      return {a:prevState.a + 1};</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    })</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/BUPTlhuanyu/ReactNote/tree/master/docs/react/react/reconciler/多次执行setState的更新机制.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_2_ui" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_13-_"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/ReactNote/docs/react/react/reconciler/expiration-time"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« 到期时间</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/ReactNote/docs/react/react/reconciler/react-fiber-lazy-component"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">ReactFiberLazyComponent »</div></a></div></nav></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2021 BUPTlhuanyu, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/ReactNote/assets/js/runtime~main.ee2f40a8.js"></script>
<script src="/ReactNote/assets/js/main.33abd88d.js"></script>
</body>
</html>