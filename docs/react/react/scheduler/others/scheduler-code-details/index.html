<!doctype html>
<html class="docs-version-current" lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.6">
<link rel="alternate" type="application/rss+xml" href="/ReactNote/blog/rss.xml" title="React Note Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/ReactNote/blog/atom.xml" title="React Note Blog Atom Feed"><title data-react-helmet="true">React Note</title><meta data-react-helmet="true" property="og:title" content="React Note"><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://BUPTlhuanyu.github.io/ReactNote/docs/react/react/scheduler/others/scheduler-code-details"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" name="description" content="1、为各个事件回调函数设置相应的优先级，然后根据自定义或者默认优先级确定到期时间，以此为基础，构建一个双向循环列表当做任务队列，每个节点存储了任务的回调函数以及到期时间，优先级，前一个节点后一个节点。"><meta data-react-helmet="true" property="og:description" content="1、为各个事件回调函数设置相应的优先级，然后根据自定义或者默认优先级确定到期时间，以此为基础，构建一个双向循环列表当做任务队列，每个节点存储了任务的回调函数以及到期时间，优先级，前一个节点后一个节点。"><link data-react-helmet="true" rel="shortcut icon" href="/ReactNote/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://BUPTlhuanyu.github.io/ReactNote/docs/react/react/scheduler/others/scheduler-code-details"><link data-react-helmet="true" rel="alternate" href="https://BUPTlhuanyu.github.io/ReactNote/docs/react/react/scheduler/others/scheduler-code-details" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://BUPTlhuanyu.github.io/ReactNote/docs/react/react/scheduler/others/scheduler-code-details" hreflang="x-default"><link rel="stylesheet" href="/ReactNote/assets/css/styles.694d919f.css">
<link rel="preload" href="/ReactNote/assets/js/runtime~main.e43eda9f.js" as="script">
<link rel="preload" href="/ReactNote/assets/js/main.54e606af.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/ReactNote/"><img src="/ReactNote/img/logo.png" alt="React Note Logo" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/ReactNote/img/logo.png" alt="React Note Logo" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"><b class="navbar__title">React Note</b></a><a class="navbar__item navbar__link navbar__link--active" href="/ReactNote/docs/react/react/intro">React</a><a class="navbar__item navbar__link" href="/ReactNote/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/BUPTlhuanyu" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="react-toggle toggle_3Zt9 react-toggle--disabled"><div class="react-toggle-track" role="button" tabindex="-1"><div class="react-toggle-track-check"><span class="toggle_71bT">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_71bT">🌞</span></div><div class="react-toggle-thumb"></div></div><input type="checkbox" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper docs-doc-page"><div class="docPage_31aa"><button class="clean-btn backToTopButton_35hR" type="button"><svg viewBox="0 0 24 24" width="28"><path d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z" fill="currentColor"></path></svg></button><aside class="docSidebarContainer_3Kbt"><div class="sidebar_15mo"><nav class="menu thin-scrollbar menu_Bmed menuWithAnnouncementBar_2WvA"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#">react</a><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/ReactNote/docs/react/react/intro">介绍</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/ReactNote/docs/react/react/project-directory">目录结构</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/ReactNote/docs/react/react/shared">公共方法</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="0">ReactElement</a></li><li class="theme-doc-sidebar-item-category menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#" tabindex="0">scheduler</a><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/ReactNote/docs/react/react/scheduler/why-need-scheduler">为什么需要scheduler</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/ReactNote/docs/react/react/scheduler/new-scheduler">新版scheduler</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/ReactNote/docs/react/react/scheduler/old-scheduler">对齐frame版本的scheduler</a></li><li class="theme-doc-sidebar-item-category menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#" tabindex="0">其他</a><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/ReactNote/docs/react/react/scheduler/others/react-is">react-is</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/ReactNote/docs/react/react/scheduler/others/scheduler-code-details">scheduler-code-details</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/ReactNote/docs/react/react/scheduler/others/scheduler-tracing-subscriptions">scheduler-tracing-subscriptions</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/ReactNote/docs/react/react/scheduler/others/scheduler-tracing">scheduler-tracing</a></li></ul></li></ul></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="0">reconciler</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="0">event</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/ReactNote/docs/react/react/error/error-handle">如何处理错误</a></li></ul></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">react-hook-form</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">react-router</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">react-transition</a></li></ul></nav></div></aside><main class="docMainContainer_3ufF"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_3FnS"><div class="docItemContainer_33ec"><article><div class="tocCollapsible_1PrD theme-doc-toc-mobile tocMobile_3Hoh"><button type="button" class="clean-btn tocCollapsibleButton_2O1e">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>设计思想</h1></header><p>1、为各个事件回调函数设置相应的优先级，然后根据自定义或者默认优先级确定到期时间，以此为基础，构建一个双向循环列表当做任务队列，每个节点存储了任务的回调函数以及到期时间，优先级，前一个节点后一个节点。</p><p>2、形成的任务链表的执行准则是：当前帧有空闲时间，则执行任务。即便没有空闲时间但是当前任务链表有任务到期了或者有立即执行任务，那么必须执行的时候就以丢失几帧的代价，执行任务链表中到期的任务。执行完的任务都会被从链表中删除。每次在执行任务链表中到期的任务的那段时间里，顺便把优先级最高需要立即执行的任务都执行。</p><p>总览图：flush*为任务执行模块，主要用于执行任务的回调函数，对任务链表进行操作。idleTick与animationTick为直接调度模块，根据当前帧的空闲时间与任务链表最小到期时间来控制是否在当前帧执行任务链表还是在下一帧继续处理。ensureHostCallbackIsScheduled与requestHostCallback组成任务执行模块与调度模块的枢纽，协调两者的工作，并且ensureHostCallbackIsScheduled为外部API提供入口。</p><p><img src="/ReactNote/assets/images/scheduler-89f3ab83ca7250ef90c1572e772b9cf1.png"></p><header><h1>例子</h1></header><p>考虑一种比较简单的逻辑，任务链表的执行主要是通过idleTick函数调用flushWork实现的，因此分析idleTick函数处理的三种情况：</p><p>情况1：当前帧截止时间大于当前时间，说明当前帧还有时间执行任务链表节点中的回调函数，因此执行flushWork。</p><p>情况2：如果当前帧截止时间小于或者等于当前时间，说明当前帧过期了，没有剩余时间执行任务回调函数，但是如果任务链表的最小到期时间已经过期了或者有立即执行的任务，那么说明这个任务链表中的任务非得执行不可，那就直接阻塞渲染，将接下的几个渲染帧的时间用来执行当前过期的任务链表。</p><p>情况3：如果当前帧截止时间小于或者等于当前时间，说明当前帧过期了，没有剩余时间执行任务回调函数，并且任务链表的最小到期时间还没到，因此这个任务链表还不急着执行，可以放到下一帧（animation frame fire的时候调用animationTick触发Message事件调用idleTick）去处理，依然分三种情况进行处理。</p><p>给出一张图如下或许你会有一个更加清晰的理解：</p><p><img src="/ReactNote/assets/images/scheduler基本流程-70d144bd9985feaa4bdf61c5a04d9284.png"></p><header><h1>优先级以及对应的过期时间</h1></header><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="五个优先级"></a>五个优先级<a class="hash-link" href="#五个优先级" title="Direct link to heading">#</a></h3><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">var ImmediatePriority = 1;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">var UserBlockingPriority = 2;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">var NormalPriority = 3;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">var LowPriority = 4;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">var IdlePriority = 5;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="五个优先级对应的过期时间"></a>五个优先级对应的过期时间<a class="hash-link" href="#五个优先级对应的过期时间" title="Direct link to heading">#</a></h3><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">var maxSigned31BitInt = 1073741823;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">//  过期时间</span></span><span class="token-line" style="color:#393A34"><span class="token plain">var IMMEDIATE_PRIORITY_TIMEOUT = -1;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">var USER_BLOCKING_PRIORITY = 250;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">var NORMAL_PRIORITY_TIMEOUT = 5000;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">var LOW_PRIORITY_TIMEOUT = 10000;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">var IDLE_PRIORITY = maxSigned31BitInt;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><header><h1>一些变量</h1></header><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">// 回调函数被存储双向循环链表中</span></span><span class="token-line" style="color:#393A34"><span class="token plain">var firstCallbackNode = null;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">//当前事件开始时间</span></span><span class="token-line" style="color:#393A34"><span class="token plain">var currentEventStartTime = -1;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">//当前事件到期时间</span></span><span class="token-line" style="color:#393A34"><span class="token plain">var currentExpirationTime = -1;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><header><h1>预备知识</h1></header><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="浏览器渲染帧与显示屏的刷新频率"></a>浏览器渲染帧与显示屏的刷新频率<a class="hash-link" href="#浏览器渲染帧与显示屏的刷新频率" title="Direct link to heading">#</a></h3><p>帧：通俗来说就是一张一张展示的画面（学过电视原理的应该不会陌生，本人本科学电子做硬件的。），
由于现在广泛使用的屏幕都有固定的刷新率（比如最新的一般在 60Hz）， 在两次硬件刷新之间浏览器进行两次重绘是没有意义的只会消耗性能。因此浏览器的渲染出一帧画面的间隔应该就是硬件的每一帧图像的时间间隔，即刷新频率的倒数。</p><p>那么在浏览器呈现两幅图像的空闲（idle）时间里，也就是16.7ms的时间里需要执行如下操作：</p><ul><li>脚本执行（JavaScript）：脚本造成了需要重绘的改动，比如增删 DOM、请求动画等</li><li>样式计算（CSS Object Model）：级联地生成每个节点的生效样式。</li><li>布局（Layout）：计算布局，执行渲染算法</li><li>重绘（Paint）：各层分别进行绘制（比如 3D 动画）</li><li>合成（Composite）：合成各层的渲染结果</li></ul><p>在这16.7ms中，包括了js脚本执行，需要js线程，而渲染需要的是gui渲染线程，而这两个线程是互斥的。由于GUI渲染线程与JavaScript执行线程是互斥的关系，当浏览器在执行JavaScript程序的时候，GUI渲染线程会被保存在一个队列中，直到JS程序执行完成，才会接着执行。因此如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。</p><p>如下图所示为渲染帧，代码在github中reactNote仓库中，这里展示一下：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">var start = null;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">var element = document.getElementById(&quot;move&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">element.style.position = &#x27;absolute&#x27;;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">function step(timestamp) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    console.log(&quot;timestamp&quot;,timestamp)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!start) start = timestamp;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    var progress = timestamp - start;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    element.style.left = Math.min(progress / 10, 200) + &#x27;px&#x27;;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (progress &lt; 400) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        window.requestAnimationFrame(step);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        window.postMessage({},&quot;*&quot;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">var idleTick = function(){</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    console.log(&quot;idleTick&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">window.addEventListener(&#x27;message&#x27;, idleTick, false);</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">window.requestAnimationFrame(step);</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p><img src="/ReactNote/assets/images/js渲染帧-d6f57fb5a30e4ee25e6a33ccd8d82ad8.png"></p><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_31ik" id="注意"></a>注意：<a class="hash-link" href="#注意" title="Direct link to heading">#</a></h4><p>1、从图中可以看到布局重绘合成之后并不代表是帧的结束。本文的当前帧截止时间frameDeadLine是animation frame fired开始时间 + activeFrameTime，activeFrameTime这个值就是FPS，也就是浏览器当前的刷新频率，表示流畅程度，这个值随着系统的运行而变化。</p><p>2、从图中还可以看到postmessage在合成之后执行。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="windowrequestanimationframe"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame" target="_blank" rel="noopener noreferrer">window.requestAnimationFrame</a><a class="hash-link" href="#windowrequestanimationframe" title="Direct link to heading">#</a></h3><p>当你准备更新动画时你应该调用此方法。这将使浏览器在下一次重绘之前调用你传入给该方法的动画函数(即你的回调函数)。回调函数执行次数通常是每秒60次，但在大多数遵循W3C建议的浏览器中，回调函数执行次数通常与浏览器屏幕刷新次数相匹配。为了提高性能和电池寿命，因此在大多数浏览器里，当<code>requestAnimationFrame()</code> 运行在后台标签页或者隐藏的<code>&lt;iframe&gt;</code> 里时，<code>requestAnimationFrame()</code> 会被暂停调用以提升性能和电池寿命。</p><p><strong>参数：</strong></p><p>对于传入的回调函数：下一次重绘之前更新动画帧所调用的函数。该回调函数会被传入<code>DOMHighResTimeStamp</code>参数，该参数与<code>performance.now()</code>的返回值相同，它表示<code>requestAnimationFrame() </code>开始去执行回调函数的时刻。</p><p><strong>返回值：</strong></p><p>一个 long 整数，请求 ID ，是回调列表中唯一的标识。是个非零值，没别的意义。你可以传这个值给 window.cancelAnimationFrame() 以取消回调函数。</p><p>注意：若你想在浏览器下次重绘之前继续更新下一帧动画，那么回调函数自身必须再次调用<code>window.requestAnimationFrame()</code></p><p>例如：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">var start = null;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">var element = document.getElementById(&#x27;SomeElementYouWantToAnimate&#x27;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">element.style.position = &#x27;absolute&#x27;;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">function step(timestamp) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  if (!start) start = timestamp;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  var progress = timestamp - start;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  element.style.left = Math.min(progress / 10, 200) + &#x27;px&#x27;;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  if (progress &lt; 2000) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    window.requestAnimationFrame(step);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">window.requestAnimationFrame(step);</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>这个例子中，第一次调用的时候当前的毫秒数赋值给timestamp并保存在start中，然后progress=0，元素保持不动，并调用<code>window.requestAnimationFrame(step)</code>在浏览器下次重绘之前继续更新下一帧动画。假设刷新频率为每秒60次，因此大约16.6ms之后刷新下一次，执行下一帧动画，此时传入step中的timestamp = performance.now() = 16.6，progress = 16.6，元素向左移动16.6px。这样循环下去，<code>progress &gt; 2000</code>停止执行该动画。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="windowcancelanimationframe"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/cancelAnimationFrame" target="_blank" rel="noopener noreferrer">window.cancelAnimationFrame</a><a class="hash-link" href="#windowcancelanimationframe" title="Direct link to heading">#</a></h3><p>取消一个先前通过调用window.requestAnimationFrame()方法添加到计划中的动画帧请求。</p><header><h1>一些工具函数</h1></header><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="getcurrenttime"></a>getCurrentTime<a class="hash-link" href="#getcurrenttime" title="Direct link to heading">#</a></h3><p>注意<a href="https://developer.mozilla.org/en-US/docs/Web/API/DOMHighResTimeStamp#The_time_origin" target="_blank" rel="noopener noreferrer">window.performance.now()</a>返回的是一个以毫秒为单位的数值，表示从打开当前文档到该命令执行的时候经历的毫秒数。Date.now()方法返回自1970年1月1日 00:00:00 UTC到当前时间的毫秒数。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">var getCurrentTime; </span></span><span class="token-line" style="color:#393A34"><span class="token plain">var localDate = Date;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">if (hasNativePerformanceNow) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  var Performance = performance;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  getCurrentTime = function() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return Performance.now();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  };</span></span><span class="token-line" style="color:#393A34"><span class="token plain">} else {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  getCurrentTime = function() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return localDate.now();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  };</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="requestanimationframewithtimeout"></a>requestAnimationFrameWithTimeout<a class="hash-link" href="#requestanimationframewithtimeout" title="Direct link to heading">#</a></h3><p>为了提高性能和电池寿命，在大多数浏览器里，当<code>requestAnimationFrame()</code> 运行在后台标签页或者隐藏的<code>&lt;iframe&gt;</code> 里时，<code>requestAnimationFrame()</code> 会被暂停调用以提升性能和电池寿命。但是react希望在后台运行的时候也能继续工作，所以封装了requestAnimationFrameWithTimeout来解决这个问题。</p><p>requestAnimationFrameWithTimeout的原理是运行在后台的时候，调用window.cancelAnimationFrame取消requestAnimationFrame()，利用定时器来执行callback；而在调用requestAnimationFrame的时候，清除定时器，执行callback</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">var localRequestAnimationFrame =</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    typeof requestAnimationFrame === &#x27;function&#x27;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    ? requestAnimationFrame</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    : undefined;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">var localCancelAnimationFrame =</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    typeof cancelAnimationFrame === &#x27;function&#x27; ? cancelAnimationFrame : undefined;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">var localSetTimeout = typeof setTimeout === &#x27;function&#x27; ? setTimeout :   undefined;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">var localClearTimeout =</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    typeof clearTimeout === &#x27;function&#x27; ? clearTimeout : undefined;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">var ANIMATION_FRAME_TIMEOUT = 100;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">var rAFID;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">var rAFTimeoutID;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">var requestAnimationFrameWithTimeout = function(callback) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  //在调用requestAnimationFrame的时候，清除定时器</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  rAFID = localRequestAnimationFrame(function(timestamp) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // cancel the setTimeout</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    localClearTimeout(rAFTimeoutID);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    callback(timestamp);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  });</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  //在转到后台的时候，使用定时器执行回调函数</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  rAFTimeoutID = localSetTimeout(function() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // cancel the requestAnimationFrame</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    localCancelAnimationFrame(rAFID);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    callback(getCurrentTime());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }, ANIMATION_FRAME_TIMEOUT);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><header><h1>主逻辑：利用Message事件与requestAnimationFrame进行调度</h1></header><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="关键变量"></a>关键变量<a class="hash-link" href="#关键变量" title="Direct link to heading">#</a></h3><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">  // scheduledHostCallback为任务队列执行器，存在表示有任务需要执行，不存在表示任务队列为空，</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 在requestHostCallback中设置为某个callback</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  var scheduledHostCallback = null;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  var isMessageEventScheduled = false; //是否是否安排了Message事件的标记，animationTick中执行postMessage之前将其置为true，只有在执行了Message回调函数idleTick中以及用于取消任务的cancelHostCallback函数中中才会将其置为false。</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  var timeoutTime = -1; //代表最高优先级任务firstCallbackNode的过期时间</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  var isAnimationFrameScheduled = false;//用于标记是否已经执行了requestAnimationFrameWithTimeout</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  var isFlushingHostCallback = false;//标记正在执行任务执行器，该标记相当于一个锁。作用是isFlushingHostCallback参与决定是否允许postMessage</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  var frameDeadline = 0; //当前帧截止时间</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  var previousFrameTime = 33; // 用于保存上一帧的时间</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  var activeFrameTime = 33; // 一帧的渲染时间33ms，这里假设 1s 30帧</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span></span><span class="token-line" style="color:#393A34"><span class="token plain">  //安全检查</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  var messageKey =</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    &#x27;__reactIdleCallback$&#x27; +</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    Math.random()</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      .toString(36)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      .slice(2);</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="监听message事件"></a>监听Message事件<a class="hash-link" href="#监听message事件" title="Direct link to heading">#</a></h3><p>监听Message事件，传入回调函数，不允许捕获阶段触发。idleTick是用于在监听到Message事件触发的时候执行的回调函数。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">window.addEventListener(&#x27;message&#x27;, idleTick, false);</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="监听message事件传入的回调函数idletick"></a>监听Message事件传入的回调函数idleTick<a class="hash-link" href="#监听message事件传入的回调函数idletick" title="Direct link to heading">#</a></h3><p>idleTick流程如下：</p><p>1、通过将当前帧截止时间与当前时间对比，判断当前帧是否有空余时间执行任务，如果有则到步骤3。</p><p>2、判断任务队列最小的到期时间小于当前时间，如果是，说明已经过期，将didTimeout标志置为true，执行第3步。如果还没有过期，并且没有调用requestAnimationFrameWithTimeout来设置在出现之后立马执行animationTick函数，则调用requestAnimationFrameWithTimeout。如果已经设置过了，就还原任务队列与到期时间并返回。</p><p>3、如果任务执行器存在，<code>isFlushingHostCallback = true</code>标记正在执行任务执行器，然后执行任务执行器中的逻辑prevScheduledCallback(didTimeout)，最后<code>isFlushingHostCallback = false</code>标记没有正在执行任务执行器。其中isFlushingHostCallback作用是参与决定是否允许postMessage。该标记在requestHostCallback中会见到，与该函数传入的absoluteTimeout一起决定是否window.postMessage(messageKey, &#x27;*&#x27;);（此步骤如果第1步来的，didTimeout为false，第2步来的，则为true，表示任务队列的任务最小的到期时间对应的任务已经过期了。）</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">  var idleTick = function(event) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (event.source !== window || event.data !== messageKey) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      return;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    isMessageEventScheduled = false;  //animationTick中执行postMessage之前将其置为true，只有在执行了Message回调函数idleTick中才会将其置为false。</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    var prevScheduledCallback = scheduledHostCallback;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    var prevTimeoutTime = timeoutTime;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    //置空任务队列执行器以及队列中firstNode中的最小的到期时间</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    scheduledHostCallback = null;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    timeoutTime = -1;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    //获取当前时间</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    var currentTime = getCurrentTime();</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    //标记任务队列最小的到期时间的节点以及当前帧截止时间是否过期</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    var didTimeout = false;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (frameDeadline - currentTime &lt;= 0) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      // frameDeadline表示当前帧截止时间</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      // currentTime 表示当前时刻</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      // 如果当前时刻大于frameDeadline，说明发生了阻塞，已经丢失了一帧</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      //  如果小于，说明当前帧没有空闲时间，</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      // There&#x27;s no time left in this idle period. Check if the callback has</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      // a timeout and whether it&#x27;s been exceeded.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      if (prevTimeoutTime !== -1 &amp;&amp; prevTimeoutTime &lt;= currentTime) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        //任务队列最小的到期时间小于当前时间，说明已经过期，将其标志置为true</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Exceeded the timeout. Invoke the callback even though there&#x27;s no</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // time left.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        didTimeout = true;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      } else {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        //如果没有过期</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // No timeout.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (!isAnimationFrameScheduled) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">          //没有设置requestAnimationFrameWithTimeout，将其标志isAnimationFrameScheduled置为true</span></span><span class="token-line" style="color:#393A34"><span class="token plain">          //并调用requestAnimationFrameWithTimeout</span></span><span class="token-line" style="color:#393A34"><span class="token plain">          // Schedule another animation callback so we retry later.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">          isAnimationFrameScheduled = true;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">          requestAnimationFrameWithTimeout(animationTick);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Exit without invoking the callback.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        //  恢复任务队列与到期时间并返回</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        scheduledHostCallback = prevScheduledCallback;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        timeoutTime = prevTimeoutTime;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    //如果当前帧还有空闲时间，就执行执行器，此时执行器中的didTimeout=false，表示没有过期（此处有疑问，难道能确保最小到期时间小于当前时间？）</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    //如果当前队列中最小的到期时间已经过期了，就说明应该立即执行队列中的该任务</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (prevScheduledCallback !== null) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      //标记正在执行任务执行器，该标记相当于一个锁。作用是isFlushingHostCallback参与决定是否允许postMessage</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      isFlushingHostCallback = true;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      try {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        //执行任务执行器中的逻辑</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        prevScheduledCallback(didTimeout);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      } finally {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        //执行完之后置为false</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        isFlushingHostCallback = false;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  };</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="animation-frame-fired的回调函数animationtick"></a>animation frame fired的回调函数animationTick<a class="hash-link" href="#animation-frame-fired的回调函数animationtick" title="Direct link to heading">#</a></h3><p>回调函数idleTick中在不立即执行任务执行器的时候，并且没有设置animationTick回调，则会执行requestAnimationFrameWithTimeout(animationTick)并退出，其中animationTick的作用如下：</p><p>1、如果任务执行器不为空，则在下一帧继续执行animationTick回调函数，并到第2步。如果任务执行器为空，表明没有任务需要在空闲时间里执行了，将isAnimationFrameScheduled标志置为false，表示没有设置animationTick，然后直接返回。
2、动态调整渲染一帧的时间，并计算出当前帧截止时间为当前时间 + 调整后的时间间隔
3、根据isMessageEventScheduled判断是否执行postMessage，避免打断之前安排的Message时间。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">var animationTick = function(rafTime) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (scheduledHostCallback !== null) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      //如果任务执行器不为空，则在下一帧继续执行animationTick回调函数</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      requestAnimationFrameWithTimeout(animationTick);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      // 如果没有任务需要执行，直接返回，</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      isAnimationFrameScheduled = false; //代表没有任务需要AnimationFrame执行</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      return;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    //经过几次屏幕刷新之后，动态计算出正确的刷新频率</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    //  下一帧的时间 = 当前时间 - 当前帧截止时间 + 时间间隔</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    //  如果浏览器刷新频率刚好是30hz，则nextFrameTime为0</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    //  如果刷新频率高于30hz，</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    var nextFrameTime = rafTime - frameDeadline + activeFrameTime;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      nextFrameTime &lt; activeFrameTime &amp;&amp;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      previousFrameTime &lt; activeFrameTime</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    ) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      if (nextFrameTime &lt; 8) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        nextFrameTime = 8;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      activeFrameTime =</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        nextFrameTime &lt; previousFrameTime ? previousFrameTime : nextFrameTime;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      previousFrameTime = nextFrameTime;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    //当前帧截止时间 = 当前时间 + 调整后的时间间隔</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    frameDeadline = rafTime + activeFrameTime;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (!isMessageEventScheduled) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      isMessageEventScheduled = true;//标记已经执行了postMessage</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      window.postMessage(messageKey, &#x27;*&#x27;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  };</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="任务执行器对postmessage与requestanimationframewithtimeout行为调度的关键函数"></a>任务执行器对postMessage与requestAnimationFrameWithTimeout行为调度的关键函数<a class="hash-link" href="#任务执行器对postmessage与requestanimationframewithtimeout行为调度的关键函数" title="Direct link to heading">#</a></h2><p>任务执行器在某些条件下会调用一下三个函数来发起postMessage或者requestAnimationFrameWithTimeout对空闲时间内任务执行器的执行进行调度与控制。其中任务执行器会通过调用ensureHostCallbackIsScheduled函数来决定是调用否调用cancelHostCallback来清空执行器，到期时间以及是否是否安排了Message事件的标记；最后会调用requestHostCallback来重新设置任务执行器，并立即执行任务或者稍后执行任务。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="被任务执行器调用以获取当前帧是否过期的函数shouldyieldtohost"></a>被任务执行器调用以获取当前帧是否过期的函数：shouldYieldToHost<a class="hash-link" href="#被任务执行器调用以获取当前帧是否过期的函数shouldyieldtohost" title="Direct link to heading">#</a></h3><p>shouldYieldToHost返回当前帧是否过期，如果当前帧截止时间小于当前时间说明当前帧过期了，没有空闲时间了。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">    var frameDeadline = 0;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    shouldYieldToHost = function() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return frameDeadline &lt;= getCurrentTime();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    };</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="被任务执行器调用以控制postmessage行为的函数cancelhostcallback"></a>被任务执行器调用以控制postMessage行为的函数：cancelHostCallback<a class="hash-link" href="#被任务执行器调用以控制postmessage行为的函数cancelhostcallback" title="Direct link to heading">#</a></h3><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">  //清除执行器，到期时间以及是否是否安排了Message事件的标记</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  cancelHostCallback = function() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    scheduledHostCallback = null;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    isMessageEventScheduled = false;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    timeoutTime = -1;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  };</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="被任务执行器调用以重新设置执行器控制postmessage与requestanimationframewithtimeout行为的函数requesthostcallback"></a>被任务执行器调用以重新设置执行器控制postMessage与requestAnimationFrameWithTimeout行为的函数：requestHostCallback<a class="hash-link" href="#被任务执行器调用以重新设置执行器控制postmessage与requestanimationframewithtimeout行为的函数requesthostcallback" title="Direct link to heading">#</a></h3><p>requestHostCallback函数用于设置任务执行器，与到期时间，该函数可以重新运行一个新的任务执行器。其逻辑是：如果通过该函数设置了任务执行器，并设定了新的到期时间，根据isFlushingHostCallback表示的是否有任务执行器正在执行的标记以及到期时间，处理任务执行器是立即执行还是在下一帧进行调度。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">  requestHostCallback = function(callback, absoluteTimeout) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    //给scheduledHostCallback任务执行器设置相应的执行逻辑</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    scheduledHostCallback = callback;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    //设定到期时间</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    timeoutTime = absoluteTimeout;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (isFlushingHostCallback || absoluteTimeout &lt; 0) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      //立即执行，通过postMessage触发Message事件，在idleTick中执行执行器中的逻辑即callback</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      // Don&#x27;t wait for the next frame. Continue working ASAP, in a new event.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      window.postMessage(messageKey, &#x27;*&#x27;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else if (!isAnimationFrameScheduled) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      //如果不是立即执行，并且还没有执行requestAnimationFrameWithTimeout设置下一帧刷新时的动作</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      //那么设置isAnimationFrameScheduled标记，并requestAnimationFrameWithTimeout</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      // If rAF didn&#x27;t already schedule one, we need to schedule a frame.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      // TODO: If this rAF doesn&#x27;t materialize because the browser throttles, we</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      // might want to still have setTimeout trigger rIC as a backup to ensure</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      // that we keep performing work.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      isAnimationFrameScheduled = true;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      requestAnimationFrameWithTimeout(animationTick);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  };</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><header><h1>任务执行器flushWork</h1></header><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="工具函数ensurehostcallbackisscheduled"></a>工具函数ensureHostCallbackIsScheduled<a class="hash-link" href="#工具函数ensurehostcallbackisscheduled" title="Direct link to heading">#</a></h3><p>如果当前正在执行最高优先级的回调函数，则返回。否则，清空当前空闲时间安排的任务队列，重新设置任务执行器，并在requestHostCallback函数中调用postMessage触发Message事件
，在回调函数idleTick中立即执行任务执行器或者执行requestAnimationFrameWithTimeout将任务执行器的执行与否放到下一帧来判断</p><p>流程：</p><p>1、通过isExecutingCallback标记判断是否正在执行最高优先级的回调函数，如果是的，直接返回。如果不是继续执行第2步</p><p>2、获取最小的到期时间，即双向链表第一个节点的到期时间。根据isHostCallbackScheduled标记来判断帧与帧之间的时间间隔即空闲时间是否安排了回调函数（fasle表示没有安排回调函数），如果安排了回调函数，那么需要调用cancelHostCallback函数来清除任务执行器，到期时间以及是否是否安排了Message事件的标记。否则将isHostCallbackScheduled标记设置为true</p><p>3、执行requestHostCallback(flushWork, expirationTime)，传入第一个节点的到期时间，重新设置任务执行器，并立即执行任务或者稍后执行任务</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">function ensureHostCallbackIsScheduled() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  //是否正在执行最高优先级的回调函数</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  if (isExecutingCallback) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // Don&#x27;t schedule work yet; wait until the next time we yield.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  // Schedule the host callback using the earliest expiration in the list.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  //  获取最小的到期时间</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  var expirationTime = firstCallbackNode.expirationTime;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  //当前空闲时间还没有安排回调</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  if (!isHostCallbackScheduled) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    //将标志置为true</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    isHostCallbackScheduled = true;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  } else {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    //如果已经安排回调，则清除任务执行器，到期时间以及是否是否安排了Message事件的标记</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // Cancel the existing host callback.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    cancelHostCallback();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  //传入第一个节点的到期时间，重新设置任务执行器，并在requestHostCallback函数中调用postMessage触发Message事件</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 在回调函数idleTick中立即执行任务执行器或者执行requestAnimationFrameWithTimeout将任务执行器的执行与否放到下一帧来判断</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  requestHostCallback(flushWork, expirationTime);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="任务执行器flushwork-1"></a>任务执行器flushWork<a class="hash-link" href="#任务执行器flushwork-1" title="Direct link to heading">#</a></h3><p>传入的参数didTimeout为true，表示任务队列最小到期时间对应的任务已经过期了，需要立即执行
为false，表示当前帧有空余时间</p><p>流程：</p><p>1、将正在执行回调的标记isExecutingCallback置为true，保存当前的过期标志，重新设置当前的过期标志，如果过期了，执行第2步；如果没有过期，执行第3步。</p><p>2、依次执行firstCallbackNode任务队列第一个节点的回调函数，然后从firstCallbackNode任务队列中删除第一个节点。直到第一个节点还没有过期或者任务队列都执行了回调函数。判断节点是否过期，根据当前时间与节点存储的到期时间比较来判断。</p><p>3、依次执行firstCallbackNode任务队列第一个节点的回调函数，然后从firstCallbackNode任务队列中删除第一个节点。直到任务队列为空或者当前时间大于当前帧截止时间。</p><p>4、将回调正在执行的标记isExecutingCallback置为false，并恢复过期标志。最后判断，任务队列是否为空，如果为空则标记<code>isHostCallbackScheduled = false</code>，表示空闲时间没有安排任务队列。如果不为空，则执行ensureHostCallbackIsScheduled，将剩下的任务队列安排到在下一空闲时间段。</p><p>5、最后执行flushImmediateWork，执行任务队列中所有立即执行任务(最高优先级)的回调函数。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">function flushWork(didTimeout) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  isExecutingCallback = true;//表示正在执行回调</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  const previousDidTimeout = currentDidTimeout;//保存当前的过期标志到previousDidTimeout</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  currentDidTimeout = didTimeout;//重新设置当前的过期标志</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  try {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (didTimeout) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      // Flush all the expired callbacks without yielding.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        //如果过期了</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      while (firstCallbackNode !== null) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">          // 第一个节点不为空，并且第一个节点过期了，则一直循环，直到第一个节点为空或者没有过期。</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Read the current time. Flush all the callbacks that expire at or</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // earlier than that time. Then read the current time again and repeat.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // This optimizes for as few performance.now calls as possible.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        //  刷新当前时间</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        var currentTime = getCurrentTime();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (firstCallbackNode.expirationTime &lt;= currentTime) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">          //如果第一个节点的到期时间小于当前时间，过期了</span></span><span class="token-line" style="color:#393A34"><span class="token plain">          do {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            //flushFirstCallback()：执行第一个节点的回调函数，并从链表中删除当前的第一个节点</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            flushFirstCallback();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">          } while (</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            //  直到第一个节点为空或者第一个节点没有过期</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            firstCallbackNode !== null &amp;&amp;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            firstCallbackNode.expirationTime &lt;= currentTime</span></span><span class="token-line" style="color:#393A34"><span class="token plain">          );</span></span><span class="token-line" style="color:#393A34"><span class="token plain">          //第一个节点为空或者第一个节点没有过期</span></span><span class="token-line" style="color:#393A34"><span class="token plain">          continue;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">          //第一个节点为不为空但是第一个节点没有过期，则退出while(firstCallbackNode !== null)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        break;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      // Keep flushing callbacks until we run out of time in the frame.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 第一个节点不为空</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      if (firstCallbackNode !== null) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        //一直循环flushFirstCallback();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">          // 直到当前帧没有空余时间可用</span></span><span class="token-line" style="color:#393A34"><span class="token plain">          // 或者第一个节点为空，即任务队列为空，则停止刷新第一个节点</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        do {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">          flushFirstCallback();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        } while (firstCallbackNode !== null &amp;&amp; !shouldYieldToHost());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  } finally {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    //最终将回调正在执行的标记置为false</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    isExecutingCallback = false;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    //恢复之前的过期标志</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    currentDidTimeout = previousDidTimeout;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (firstCallbackNode !== null) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      // 如果第一个节点不为空，表示是因为当前帧没有空余时间了，而停止了回调的执行</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      //  这个时候请求下一次的回调，继续执行剩下的任务队列</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      // There&#x27;s still work remaining. Request another callback.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      ensureHostCallbackIsScheduled();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      //如果都已经执行完了，任务队列为空的情况，则设置标记isHostCallbackScheduled为false，</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      // 空闲时间的使用权可以交给其他的任务队列</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      isHostCallbackScheduled = false;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // Before exiting, flush all the immediate work that was scheduled.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 最后刷新所有的立即执行任务</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    flushImmediateWork();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="flushfirstcallback"></a>flushFirstCallback<a class="hash-link" href="#flushfirstcallback" title="Direct link to heading">#</a></h3><p>流程：</p><p>1、执行第一个节点的回调函数，并从链表中删除当前的第一个节点，如果回调函数返回的是一个函数，则利用这个函数创建一个新节点<code>continuationNode</code></p><p>2、如果新节点的优先级最高，则执行<code>firstCallbackNode = continuationNode</code>，并调用<code>ensureHostCallbackIsScheduled</code>。否则，到第3步。</p><p>3、最后，由于新节点的到期时间与原第一个节点的到期时间一样，所以新节点将会替代原第一个节点的位置。</p><p>在上述过程中，由于第2步设计到异步事件，所以第三步会在第二步之前改变任务链表。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">function flushFirstCallback() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  //将firstCallbackNode赋值给flushedNode，作为当前需要被执行的任务节点</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  var flushedNode = firstCallbackNode;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  // Remove the node from the list before calling the callback. That way the</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  // list is in a consistent state even if the callback throws.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  //  从链表中删除第一个节点firstCallbackNode，原firstCallbackNode的后一个节点作为第一个节点</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  var next = firstCallbackNode.next;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  if (firstCallbackNode === next) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // This is the last callback in the list.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    firstCallbackNode = null;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    next = null;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  } else {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    var lastCallbackNode = firstCallbackNode.previous;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    firstCallbackNode = lastCallbackNode.next = next;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    next.previous = lastCallbackNode;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  //将当前需要被执行的任务节点的next与previous置null，断开与链表的链接</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  flushedNode.next = flushedNode.previous = null;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  // Now it&#x27;s safe to call the callback.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  var callback = flushedNode.callback;//该任务的回调函数</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  var expirationTime = flushedNode.expirationTime;//该任务的到期时间</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  var priorityLevel = flushedNode.priorityLevel;//该任务的优先级</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  var previousPriorityLevel = currentPriorityLevel;//保存当前优先级</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  var previousExpirationTime = currentExpirationTime;//保存当前到期时间</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  currentPriorityLevel = priorityLevel;//利用该任务的优先级刷新当前优先级</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  currentExpirationTime = expirationTime;//利用该任务的到期时间刷新当前到期时间</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  var continuationCallback;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  try {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    continuationCallback = callback();//执行该任务的回调函数，返回值保存在continuationCallback</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  } finally {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    //注意如果callback是异步的，这里finally的子句不会等callback执行完在执行</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    //  try...finally是同步的</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    //  调用了回调函数之后恢复原有的当前优先级与当前到期时间</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    currentPriorityLevel = previousPriorityLevel;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    currentExpirationTime = previousExpirationTime;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  // A callback may return a continuation. The continuation should be scheduled</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  // with the same priority and expiration as the just-finished callback.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  //  如果回调函数返回的是一个函数，则再创建一个任务节点</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  if (typeof continuationCallback === &#x27;function&#x27;) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    var continuationNode: CallbackNode = {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      callback: continuationCallback,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      priorityLevel,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      expirationTime,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      next: null,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      previous: null,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    };</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // Insert the new callback into the list, sorted by its expiration. This is</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // almost the same as the code in `scheduleCallback`, except the callback</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // is inserted into the list *before* callbacks of equal expiration instead</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // of after.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    //  将新生成的节点依照到期时间插入到链表中，与scheduleCallback函数中的区别是，</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    //  如果遇到相同的到期时间，则插入到其前面而不是后面</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (firstCallbackNode === null) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      // This is the first callback in the list.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      //  如果此时任务队列为空，则该新节点为链表唯一的节点</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      firstCallbackNode = continuationNode.next = continuationNode.previous = continuationNode;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else {</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      var nextAfterContinuation = null;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      var node = firstCallbackNode;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      do {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (node.expirationTime &gt;= expirationTime) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">          // This callback expires at or after the continuation. We will insert</span></span><span class="token-line" style="color:#393A34"><span class="token plain">          // the continuation *before* this callback.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">          nextAfterContinuation = node;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">          break;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        node = node.next;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      } while (node !== firstCallbackNode);</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      if (nextAfterContinuation === null) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // No equal or lower priority callback was found, which means the new</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // callback is the lowest priority callback in the list.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        nextAfterContinuation = firstCallbackNode;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      } else if (nextAfterContinuation === firstCallbackNode) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // The new callback is the highest priority callback in the list.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        //  如果返回的函数构成的节点优先级是最高的，那么需要将该节点单独设置为一个任务队列</span></span><span class="token-line" style="color:#393A34"><span class="token plain">          // 调用ensureHostCallbackIsScheduled重新设置任务执行器，并立即执行任务或者稍后执行任务</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        firstCallbackNode = continuationNode;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        ensureHostCallbackIsScheduled();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      var previous = nextAfterContinuation.previous;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      previous.next = nextAfterContinuation.previous = continuationNode;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      continuationNode.next = nextAfterContinuation;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      continuationNode.previous = previous;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="flushimmediatework"></a>flushImmediateWork<a class="hash-link" href="#flushimmediatework" title="Direct link to heading">#</a></h3><p>执行任务队列中所有立即执行任务(最高优先级)的回调函数，这些回调函数的是不能被打断的，因为在重新执行其他任务队列的时候，会先判断isExecutingCallback这个标记，如果为true，说明在执行最高优先级的回调，直接返回。</p><p>流程：</p><p>1、如果firstCallbackNode任务具备最高优先级，并且currentEventStartTime === -1（？），则标记处于正在执行最高优先级的任务的节点。</p><p>2、执行第一个节点的回调函数，直到第一个节点的优先级不是最高优先级（立即执行），由于链表是按照到期时间排序，而最高优先级对应的到期时间最小，所以都会被安排在链表前面。因此这里就是执行队列中所有的立即执行任务的回调函数</p><p>3、调用完所有的最高优先级节点的回调函数之后，将isExecutingCallback设置为false，表示现在没有执行最高优先级任务。如果还有任务没执行完，那么重新设置任务执行器，否则设置<code>isHostCallbackScheduled = false</code>表示队列为空，空闲时间没有安排任务。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">function flushImmediateWork() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  if (</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // Confirm we&#x27;ve exited the outer most event handler</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    //  currentEventStartTime表示当前事件触发的开始时间</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    //如果firstCallbackNode任务具备最高优先级，则执行回调函数</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    currentEventStartTime === -1 &amp;&amp;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    firstCallbackNode !== null &amp;&amp;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    firstCallbackNode.priorityLevel === ImmediatePriority</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  ) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    //一个锁，用于标记是否正在执行最高优先级的任务</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    isExecutingCallback = true;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    try {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        //执行第一个节点的回调函数，直到第一个节点的优先级不是最高优先级（立即执行）</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      //  由于链表是按照到期时间排序，而最高优先级对应的到期时间最小，所以都会被安排在链表前面</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      //  因此这里就是执行队列中所有的立即执行任务的回调函数</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      do {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        flushFirstCallback();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      } while (</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Keep flushing until there are no more immediate callbacks</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        firstCallbackNode !== null &amp;&amp;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        firstCallbackNode.priorityLevel === ImmediatePriority</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      );</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    } finally {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      //调用完所有的最高优先级节点的回调函数之后，将isExecutingCallback设置为false，表示现在没有执行最高优先级任务</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      isExecutingCallback = false;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      if (firstCallbackNode !== null) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // There&#x27;s still work remaining. Request another callback.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 重新设置任务执行器</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        ensureHostCallbackIsScheduled();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      } else {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        //队列为空，空闲时间没有安排任务</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        isHostCallbackScheduled = false;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><header><h1>API</h1></header><p>这只贴unstable_scheduleCallback代码以及注释，具体的注释与解析请关注<a href="https://github.com/BUPTlhuanyu/ReactNote/blob/master/react/packages/scheduler/src/Scheduler.js" target="_blank" rel="noopener noreferrer">reactNote</a>，scheduler测试代码具体可以关注<a href="https://github.com/BUPTlhuanyu/ReactNote/blob/master/react/runlogic/scheduler.html" target="_blank" rel="noopener noreferrer">reactNote</a></p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">unstable_runWithPriority</span></span><span class="token-line" style="color:#393A34"><span class="token plain">unstable_wrapCallback</span></span><span class="token-line" style="color:#393A34"><span class="token plain">unstable_scheduleCallback</span></span><span class="token-line" style="color:#393A34"><span class="token plain">unstable_cancelCallback</span></span><span class="token-line" style="color:#393A34"><span class="token plain">unstable_getCurrentPriorityLevel</span></span><span class="token-line" style="color:#393A34"><span class="token plain">unstable_shouldYield</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="unstable_schedulecallback"></a>unstable_scheduleCallback<a class="hash-link" href="#unstable_schedulecallback" title="Direct link to heading">#</a></h3><p>传入参数：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">callback，//任务的回调函数</span></span><span class="token-line" style="color:#393A34"><span class="token plain">deprecated_options //包含自定义的到期时长timeout，可以用来指定callback执行的到时间，</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                     也就是可以影响插入到已有的任务链表的位置，可以使传入的callback回调函数在当前帧paint之前执行，即立即执行。</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>功能：
计算开始时间，然后根据传入的参数deprecated_options.timeout计算到期时间 = 开始时间 + 传入的参数options中的timeout，如果deprecated_options.timeout不存在，根据默认优先级计算到期时间。封装成一个节点，如下；</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">  //新节点：保存了传入的回调函数，优先级，到期时间</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  var newNode = {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    callback,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    priorityLevel: currentPriorityLevel,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    expirationTime,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    next: null,//链表后一个节点</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    previous: null,//链表前一个节点</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  };</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>最后按照到期时间的大小，从firstNode开始以小到大的顺序插入到双向循环链表中firstCallbackNode中，返回一个新的链表。 </p><p>源码：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">function unstable_scheduleCallback(callback, deprecated_options) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    //只有unstable_wrapCallback和unstable_runWithPriority会改变currentEventStartTime</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 因此在初始状态，currentEventStartTime=-1，所以startTime = getCurrentTime()</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    var startTime =</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        currentEventStartTime !== -1 ? currentEventStartTime : getCurrentTime();</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    //计算到期时间 = 开始时间 + 传入的参数options中的timeout</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    //deprecated_options.timeout表示多少毫秒之后过期</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    var expirationTime;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        typeof deprecated_options === &#x27;object&#x27; &amp;&amp;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        deprecated_options !== null &amp;&amp;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        typeof deprecated_options.timeout === &#x27;number&#x27;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    ) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // FIXME: Remove this branch once we lift expiration times out of React.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        expirationTime = startTime + deprecated_options.timeout;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        //根据当前优先级确定过期时间</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        //   初始状态下为currentPriorityLevel为NormalPriority,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        switch (currentPriorityLevel) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            case ImmediatePriority:</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                expirationTime = startTime + IMMEDIATE_PRIORITY_TIMEOUT;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                break;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            case UserBlockingPriority:</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                expirationTime = startTime + USER_BLOCKING_PRIORITY;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                break;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            case IdlePriority:</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                expirationTime = startTime + IDLE_PRIORITY;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                break;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            case LowPriority:</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                expirationTime = startTime + LOW_PRIORITY_TIMEOUT;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                break;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            case NormalPriority:</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            default:</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                expirationTime = startTime + NORMAL_PRIORITY_TIMEOUT;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    //新节点：保存了传入的回调函数，优先级，到期时间</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    var newNode = {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        callback,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        priorityLevel: currentPriorityLevel,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        expirationTime,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        next: null,//链表后一个节点</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        previous: null,//链表前一个节点</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    };</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // Insert the new callback into the list, ordered first by expiration, then</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // by insertion. So the new callback is inserted any other callback with</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // equal expiration.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 将当前包含回调函数的节点按照到期时间从firstNode开始以小到大的顺序插入到双向循环链表中，</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (firstCallbackNode === null) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        //如果任务队列为空，则将新节点组成一个双向循环链表，并执行ensureHostCallbackIsScheduled，开始调度</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // This is the first callback in the list.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        firstCallbackNode = newNode.next = newNode.previous = newNode;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        ensureHostCallbackIsScheduled();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        //如果任务队列不为空，将新节点插入循环链表，</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        var next = null;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        var node = firstCallbackNode;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        do {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (node.expirationTime &gt; expirationTime) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                // The new callback expires before this one.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                next = node;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                break;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            node = node.next;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        } while (node !== firstCallbackNode);</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (next === null) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            //如果新节点的到期时间是最大的，则应该处于链表的末端</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            //对于双向循环链表而言，新节点的next为链表的第一个节点。</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // No callback with a later expiration was found, which means the new</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // callback has the latest expiration in the list.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            next = firstCallbackNode;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else if (next === firstCallbackNode) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // The new callback has the earliest expiration in the entire list.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            //  如果新节点的到期时间最小，则新节点就应该是链表的第一个节点</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            //  在插入之前，先执行ensureHostCallbackIsScheduled()进行调度</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            //  由于ensureHostCallbackIsScheduled的函数作用域链中最终是通过回调函数来调用flushWork函数来执行任务链表中的回调函数的，</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            //  属于异步事件，因此if外部的代码先于ensureHostCallbackIsScheduled()执行</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            firstCallbackNode = newNode;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            ensureHostCallbackIsScheduled();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        var previous = next.previous;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        previous.next = next.previous = newNode;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        newNode.next = next;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        newNode.previous = previous;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return newNode;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/BUPTlhuanyu/ReactNote/tree/master/docs/react/react/scheduler/others/scheduler细节.mdx" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_2_ui" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_13-_"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/ReactNote/docs/react/react/scheduler/others/react-is"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« react-is</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/ReactNote/docs/react/react/scheduler/others/scheduler-tracing-subscriptions"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">scheduler-tracing-subscriptions »</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_35-E thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#五个优先级" class="table-of-contents__link">五个优先级</a></li><li><a href="#五个优先级对应的过期时间" class="table-of-contents__link">五个优先级对应的过期时间</a></li><li><a href="#浏览器渲染帧与显示屏的刷新频率" class="table-of-contents__link">浏览器渲染帧与显示屏的刷新频率</a></li><li><a href="#windowrequestanimationframe" class="table-of-contents__link">window.requestAnimationFrame</a></li><li><a href="#windowcancelanimationframe" class="table-of-contents__link">window.cancelAnimationFrame</a></li><li><a href="#getcurrenttime" class="table-of-contents__link">getCurrentTime</a></li><li><a href="#requestanimationframewithtimeout" class="table-of-contents__link">requestAnimationFrameWithTimeout</a></li><li><a href="#关键变量" class="table-of-contents__link">关键变量</a></li><li><a href="#监听message事件" class="table-of-contents__link">监听Message事件</a></li><li><a href="#监听message事件传入的回调函数idletick" class="table-of-contents__link">监听Message事件传入的回调函数idleTick</a></li><li><a href="#animation-frame-fired的回调函数animationtick" class="table-of-contents__link">animation frame fired的回调函数animationTick</a></li><li><a href="#任务执行器对postmessage与requestanimationframewithtimeout行为调度的关键函数" class="table-of-contents__link">任务执行器对postMessage与requestAnimationFrameWithTimeout行为调度的关键函数</a><ul><li><a href="#被任务执行器调用以获取当前帧是否过期的函数shouldyieldtohost" class="table-of-contents__link">被任务执行器调用以获取当前帧是否过期的函数：shouldYieldToHost</a></li><li><a href="#被任务执行器调用以控制postmessage行为的函数cancelhostcallback" class="table-of-contents__link">被任务执行器调用以控制postMessage行为的函数：cancelHostCallback</a></li><li><a href="#被任务执行器调用以重新设置执行器控制postmessage与requestanimationframewithtimeout行为的函数requesthostcallback" class="table-of-contents__link">被任务执行器调用以重新设置执行器控制postMessage与requestAnimationFrameWithTimeout行为的函数：requestHostCallback</a></li><li><a href="#工具函数ensurehostcallbackisscheduled" class="table-of-contents__link">工具函数ensureHostCallbackIsScheduled</a></li><li><a href="#任务执行器flushwork-1" class="table-of-contents__link">任务执行器flushWork</a></li><li><a href="#flushfirstcallback" class="table-of-contents__link">flushFirstCallback</a></li><li><a href="#flushimmediatework" class="table-of-contents__link">flushImmediateWork</a></li><li><a href="#unstable_schedulecallback" class="table-of-contents__link">unstable_scheduleCallback</a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2021 BUPTlhuanyu, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/ReactNote/assets/js/runtime~main.e43eda9f.js"></script>
<script src="/ReactNote/assets/js/main.54e606af.js"></script>
</body>
</html>