<!doctype html>
<html class="docs-version-current" lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.6">
<link rel="alternate" type="application/rss+xml" href="/ReactNote/blog/rss.xml" title="React Note Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/ReactNote/blog/atom.xml" title="React Note Blog Atom Feed"><title data-react-helmet="true">React Note</title><meta data-react-helmet="true" property="og:title" content="React Note"><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://BUPTlhuanyu.github.io/ReactNote/docs/react/react/event/event-dispatch"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" name="description" content="概述，背景"><meta data-react-helmet="true" property="og:description" content="概述，背景"><link data-react-helmet="true" rel="shortcut icon" href="/ReactNote/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://BUPTlhuanyu.github.io/ReactNote/docs/react/react/event/event-dispatch"><link data-react-helmet="true" rel="alternate" href="https://BUPTlhuanyu.github.io/ReactNote/docs/react/react/event/event-dispatch" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://BUPTlhuanyu.github.io/ReactNote/docs/react/react/event/event-dispatch" hreflang="x-default"><link rel="stylesheet" href="/ReactNote/assets/css/styles.694d919f.css">
<link rel="preload" href="/ReactNote/assets/js/runtime~main.f75cb977.js" as="script">
<link rel="preload" href="/ReactNote/assets/js/main.af5c24bf.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/ReactNote/"><img src="/ReactNote/img/logo.png" alt="React Note Logo" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/ReactNote/img/logo.png" alt="React Note Logo" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"><b class="navbar__title">React Note</b></a><a class="navbar__item navbar__link navbar__link--active" href="/ReactNote/docs/react/react/intro">React</a><a class="navbar__item navbar__link" href="/ReactNote/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/BUPTlhuanyu" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="react-toggle toggle_3Zt9 react-toggle--disabled"><div class="react-toggle-track" role="button" tabindex="-1"><div class="react-toggle-track-check"><span class="toggle_71bT">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_71bT">🌞</span></div><div class="react-toggle-thumb"></div></div><input type="checkbox" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper docs-doc-page"><div class="docPage_31aa"><button class="clean-btn backToTopButton_35hR" type="button"><svg viewBox="0 0 24 24" width="28"><path d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z" fill="currentColor"></path></svg></button><aside class="docSidebarContainer_3Kbt"><div class="sidebar_15mo"><nav class="menu thin-scrollbar menu_Bmed menuWithAnnouncementBar_2WvA"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#">react</a><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/ReactNote/docs/react/react/intro">介绍</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/ReactNote/docs/react/react/project-directory">目录结构</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/ReactNote/docs/react/react/shared">公共方法</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="0">ReactElement</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="0">scheduler</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="0">reconciler</a></li><li class="theme-doc-sidebar-item-category menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#" tabindex="0">event</a><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/ReactNote/docs/react/react/event/event-bind">事件绑定</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/ReactNote/docs/react/react/event/event-dispatch">事件触发</a></li></ul></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/ReactNote/docs/react/react/error/error-handle">如何处理错误</a></li></ul></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">react-hook-form</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">react-router</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">react-transition</a></li></ul></nav></div></aside><main class="docMainContainer_3ufF"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_3FnS"><div class="docItemContainer_33ec"><article><div class="tocCollapsible_1PrD theme-doc-toc-mobile tocMobile_3Hoh"><button type="button" class="clean-btn tocCollapsibleButton_2O1e">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1></h1></header><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="概述背景"></a>概述，背景<a class="hash-link" href="#概述背景" title="Direct link to heading">#</a></h2><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;div onclick=&quot;alert(1)&quot;&gt;原生&lt;/div&gt;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">class APP extends React.Component{</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   render(){</span></span><span class="token-line" style="color:#393A34"><span class="token plain">       return (</span></span><span class="token-line" style="color:#393A34"><span class="token plain">           &lt;div&gt;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">               &lt;Header/&gt;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">           &lt;/div&gt;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">       )</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">class Header extends React.Component{</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   clickHandler(){</span></span><span class="token-line" style="color:#393A34"><span class="token plain">       console.log(&quot;click&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   render(){</span></span><span class="token-line" style="color:#393A34"><span class="token plain">       return (</span></span><span class="token-line" style="color:#393A34"><span class="token plain">           &lt;div&gt;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">               &lt;div onClick={this.clickHandler.bind(this)} a={1}&gt;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                   this is Header</span></span><span class="token-line" style="color:#393A34"><span class="token plain">               &lt;/div&gt;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">               &lt;p onClick={this.clickHandler.bind(this)} a={1}&gt;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                   this is Header</span></span><span class="token-line" style="color:#393A34"><span class="token plain">               &lt;/p&gt;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">           &lt;/div&gt;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">       )</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain">ReactDOM.render(</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   &lt;APP/&gt;,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   document.getElementById(&#x27;app&#x27;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">);</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p> 上述的组件中点击事件的触发过程如下：</p><p><img src="/ReactNote/assets/images/2-1-66a9335ccba82d3dce71ec690f553c7f.png">
<code>document</code>监听到某个<code>DOM</code>上冒泡上来的点击事件之后，调用<code>document</code>上的处理函数<code>dispatchInteractiveEvent</code>：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">function dispatchInteractiveEvent(topLevelType, nativeEvent) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  interactiveUpdates(dispatchEvent, topLevelType, nativeEvent);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>react 内部会根据不同的环境来实现 <code>interactiveUpdates</code>函数，在浏览器环境下，ReactDOM.js 中该函数如下，其中 <code>fn(a, b)</code> 为 <code>dispatchEvent(topLevelType, nativeEvent)</code></p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">function interactiveUpdates&lt;A, B, R&gt;(fn: (A, B) =&gt; R, a: A, b: B): R {</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> // 当多个触发事件，事件处理函数会执行多次，但是不能允许多次调用 performWork 或者 performSyncWork</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> if (isBatchingInteractiveUpdates) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   return fn(a, b);</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> }</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> // </span></span><span class="token-line" style="color:#393A34"><span class="token plain"> if (</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   !isBatchingUpdates &amp;&amp; // 批量更新，比如事件触发多次的批处理</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   !isRendering &amp;&amp; // 不处于performWorkOnRoot函数执行过程中，renderRoot与提交阶段结束之后performWorkOnRoot结束执行</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   lowestPriorityPendingInteractiveExpirationTime !== NoWork // 有挂起的交互事件</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> ) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   performWork(lowestPriorityPendingInteractiveExpirationTime, false);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   lowestPriorityPendingInteractiveExpirationTime = NoWork;</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> }</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> const previousIsBatchingInteractiveUpdates = isBatchingInteractiveUpdates;</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> const previousIsBatchingUpdates = isBatchingUpdates;</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> isBatchingInteractiveUpdates = true;</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> isBatchingUpdates = true;</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> try {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   return fn(a, b);</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> } finally {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   isBatchingInteractiveUpdates = previousIsBatchingInteractiveUpdates;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   isBatchingUpdates = previousIsBatchingUpdates;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   if (!isBatchingUpdates &amp;&amp; !isRendering) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     performSyncWork();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   }</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p><code>dispatchEvent</code>会调用<code>batchedUpdates</code>，其中会调用<code>handleTopLevel</code>，<code>handleTopLevel</code>会调用<code>runExtractedEventsInBatch</code></p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">function runExtractedEventsInBatch(topLevelType, targetInst, nativeEvent, nativeEventTarget) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 合成事件的生成以及在fiber树上通过模拟捕获与冒泡收集事件处理函数与对应节点并存储到合成事件的相关属性上</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    var events = extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 开始执行合成事件上的相关属性存储的执行事件处理函数</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    runEventsInBatch(events);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p><code>runExtractedEventsInBatch</code>函数中会先将事件名称<code>topLevelType</code>、对应的<code>react</code>元素实例<code>targetInst</code>、原生事件对象<code>nativeEvent</code>以及事件作用的<code>DOM</code>传入<code>extractEvents</code>中，<code>extractEvents</code>函数会遍历事件插件数组<code>plugins</code>，并通过传入的事件名称<code>topLevelType</code>选择对应的<code>plugin</code>，并调用该<code>plugin</code>上的<code>extractEvents</code>，生成合成事件<code>SyntheticEvent</code>，并收集事件触发的目标节点以及以上的祖先节点需要触发的事件处理函数和对于的<code>fiber</code>分别存入合成事件的<code>_dispatchListeners</code>与<code>_dispatchInstances</code>属性上，捕获阶段的函数与节点在数组靠前位置，祖先节点‘越老’其事件处理函数以及该节点在数组中的位置越靠前；冒泡阶段的函数与节点在数组靠后位置，祖先节点‘越老’其事件处理函数以及该节点在数组中的位置越靠后；</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="合成事件对象"></a>合成事件对象<a class="hash-link" href="#合成事件对象" title="Direct link to heading">#</a></h2><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">runExtractedEventsInBatch函数中合成事件对象的逻辑：</span></span><span class="token-line" style="color:#393A34"><span class="token plain">var events = ex：tractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_31ik" id="首先看合成事件对象的生成"></a>首先看合成事件对象的生成<a class="hash-link" href="#首先看合成事件对象的生成" title="Direct link to heading">#</a></h4><p>对于点击事件调用的是<code>simpleeventplugin</code>上的<code>extractEvents</code>函数，该函数会传入的参数是<code>dispatchConfig, targetInst, nativeEvent, nativeEventTarget</code>，其中<code>dispatchConfig</code>是由<code>topLevelType</code>从<code>topLevelEventsToDispatchConfig</code>数组中获取的配置，在<code>simpleeventplugin.extractEvents</code>函数中会调用如下代码根据事件配置<code>dispatchConfig</code>将事件对应的<code>react</code>元素实例、原生事件、原生事件对应的<code>DOM</code>封装成为一个合成事件。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">var event = EventConstructor.getPooled(dispatchConfig, targetInst, nativeEvent, nativeEventTarget)</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p><code>EventConstructor.getPooled</code>实际就是<code>react\packages\events\SyntheticEvent.js</code>下的<code>getPooledEvent</code>函数，从其代码中可以看到会从事件池中去取一个合成事件对象，然后利用这个对象用新的  <code>dispatchConfig,targetInst,nativeEvent,nativeInst</code>重新初始化即可；如果事件池为空，则新创建一个合成事件对象。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">function getPooledEvent(dispatchConfig, targetInst, nativeEvent, nativeInst) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  const EventConstructor = this;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  if (EventConstructor.eventPool.length) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    const instance = EventConstructor.eventPool.pop();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    EventConstructor.call(</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      instance,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      dispatchConfig,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      targetInst,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      nativeEvent,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      nativeInst,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    );</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return instance;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  return new EventConstructor(</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    dispatchConfig,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    targetInst,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    nativeEvent,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    nativeInst,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  );</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h6><a aria-hidden="true" tabindex="-1" class="anchor anchor__h6 anchorWithStickyNavbar_31ik" id="从数据结构看合成事件与原生事件的关系"></a>从数据结构看合成事件与原生事件的关系<a class="hash-link" href="#从数据结构看合成事件与原生事件的关系" title="Direct link to heading">#</a></h6><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">function SyntheticEvent(</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  dispatchConfig,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  targetInst,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  nativeEvent,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  nativeEventTarget,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  this.dispatchConfig = dispatchConfig;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  this._targetInst = targetInst;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  this.nativeEvent = nativeEvent;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  const Interface = this.constructor.Interface;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  for (const propName in Interface) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!Interface.hasOwnProperty(propName)) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      continue;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    const normalize = Interface[propName];</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (normalize) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      this[propName] = normalize(nativeEvent);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      if (propName === &#x27;target&#x27;) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.target = nativeEventTarget;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      } else {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        this[propName] = nativeEvent[propName];</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  const defaultPrevented =</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    nativeEvent.defaultPrevented != null</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      ? nativeEvent.defaultPrevented</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      : nativeEvent.returnValue === false;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  if (defaultPrevented) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.isDefaultPrevented = functionThatReturnsTrue;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  } else {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.isDefaultPrevented = functionThatReturnsFalse;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  this.isPropagationStopped = functionThatReturnsFalse;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  return this;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>可以看到原生事件存储在合成事件对象的<code>nativeEvent</code>属性上，目标<code>react</code>元素实例存储在<code>_targetInst</code>属性上，<code>dispatchConfig</code>存储在<code>dispatchConfig</code>属性上，将原生事件对应的<code>DOM</code>即<code>nativeEventTarget</code>存储在合成事件的target属性上。原生事件对象上<code>type</code>、<code>eventPhase</code>、<code>bubbles</code>、<code>cancelable</code>、<code>defaultPrevented</code>、<code>isTrusted</code>存储在合成事件相同名称的属性上。</p><h6><a aria-hidden="true" tabindex="-1" class="anchor anchor__h6 anchorWithStickyNavbar_31ik" id="为什么事件池会提高性能"></a>为什么事件池会提高性能<a class="hash-link" href="#为什么事件池会提高性能" title="Direct link to heading">#</a></h6><p>从<code>getPooledEvent</code>函数与合成事件对象的数据结构可知，<code>React</code>合成的<code>SyntheticEvent</code>采用了池的思想，从而达到节约内存，避免频繁的创建和销毁事件对象的目的。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_31ik" id="然后收集事件处理函数与对应节点并存储到合成事件对象上"></a>然后收集事件处理函数与对应节点并存储到合成事件对象上<a class="hash-link" href="#然后收集事件处理函数与对应节点并存储到合成事件对象上" title="Direct link to heading">#</a></h4><p>这个是在特定的事件插件的<code>extractEvents</code>函数中调用<code>EventConstructor.getPooled</code>获取合成事件之后进行处理函数的收集。即如下调用<code>accumulateTwoPhaseDispatches(event)</code></p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">var event = EventConstructor.getPooled(dispatchConfig, targetInst, nativeEvent, nativeEventTarget);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">accumulateTwoPhaseDispatches(event);</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p><code>accumulateTwoPhaseDispatches</code>中收集事件处理函数的调用栈为：</p><p><img src="/ReactNote/assets/images/2-2-cc4c08a1679f33c6f01db3f3cd440882.png">
traverseTwoPhase的代码在<a href="https://github.com/BUPTlhuanyu/ReactNote/blob/master/react/blog/D2/react%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90(%E4%BA%8C)%EF%BC%9Ashared%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B9%8BReactTreeTraversal.md" target="_blank" rel="noopener noreferrer">之前的文章</a>中有分析，</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">export function traverseTwoPhase(inst, fn, arg) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  const path = [];</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  //将inst的父节点入栈，数组最后的为最远的祖先</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  while (inst) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    path.push(inst);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    inst = getParent(inst);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  let i;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  //从最远的祖先开始向inst节点捕获执行fn</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  for (i = path.length; i-- &gt; 0; ) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn(path[i], &#x27;captured&#x27;, arg);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    //从inst节点开始向最远的祖先节点冒泡执行fn</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  for (i = 0; i &lt; path.length; i++) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn(path[i], &#x27;bubbled&#x27;, arg);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>在虚拟DOM树中其实就是<code>fiber</code>树，将当前事件触发的目标节点开始向上遍历的祖先节点挨个存入<code>path</code>中，然后从祖先节点开始向目标节点进行遍历对应的就是从数组的从尾向头开始遍历（这里模拟的是捕获，所以从祖先节点开始向下遍历），这个遍历过程中，将遍历到的当前节点、合成事件对象、代表捕获还是冒泡阶段的标志作为参数传入<code>accumulateDirectionalDispatches</code>，在其中执行<code>listenerAtPhase</code>获取该绑定在该节点上需要在捕获阶段触发的事件处理函数，然后将获取到的事件处理函数<code>listener</code>与事件上的存储处理函数数组<code>event._dispatchListeners</code>传入<code>accumulateInto</code>，并将当前处理函数<code>push</code>到<code>event._dispatchListeners</code>中；同样调用<code>accumulateInto</code>将捕获阶段中当前绑定了需要捕获阶段触发的事件的节点存储到<code>event._dispatchInstances</code>，至此<code>accumulateDirectionalDispatches</code>执行完毕，也就是收集到了所有需要捕获阶段执行的事件处理函数与相对应的节点分别存储在合成事件对象上的<code>_dispatchListeners</code>与<code>_dispatchInstances</code>上。捕获阶段，父节点以及其处理函数位于数组的开头部分，模拟捕获的事件触发顺序。</p><p>按照上述逻辑，冒泡阶段，对应与在<code>traverseTwoPhase</code>中的第二个<code>for</code>循环，会依次调用<code>accumulateDirectionalDispatches</code>对事件触发的目标节点以及以上的父节点进行事件处理函数与绑定了事件处理函数的节点的收集，并将这些函数与节点分别添加在合成事件的<code>_dispatchListeners</code>与<code>_dispatchInstances</code>上。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">function accumulateDirectionalDispatches(inst, phase, event) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        !inst ? warningWithoutStack$1(false, &#x27;Dispatching inst must not be null&#x27;) : void 0;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    var listener = listenerAtPhase(inst, event, phase);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (listener) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain">// 获取捕获阶段的事件名registrationName</span></span><span class="token-line" style="color:#393A34"><span class="token plain">function listenerAtPhase(inst, event, propagationPhase) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return getListener(inst, registrationName);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">// 开始根据registrationName在当前节点上的props中获取对应的事件处理函数</span></span><span class="token-line" style="color:#393A34"><span class="token plain">function getListener(inst, registrationName) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    var listener = void 0;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // TODO: shouldPreventMouseEvent is DOM-specific and definitely should not</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // live here; needs to be moved to a better place soon</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    var stateNode = inst.stateNode;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!stateNode) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Work in progress (ex: onload events in incremental mode).</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return null;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    var props = getFiberCurrentPropsFromNode(stateNode);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!props) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Work in progress.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return null;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    listener = props[registrationName];</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (shouldPreventMouseEvent(registrationName, inst.type, props)) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return null;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    !(!listener || typeof listener === &#x27;function&#x27;) ? invariant(false, &#x27;Expected `%s` listener to be a function, instead got a value of `%s` type.&#x27;, registrationName, typeof listener) : void 0;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return listener;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>至此对于下面的结构：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">&lt;div id=&#x27;div1&#x27; onClick={this.clickHandler1.bind(this)} a={1}&gt;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    &lt;div id=&#x27;div2&#x27; onClick={this.clickHandler2.bind(this)} a={1}&gt;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        &lt;div id=&#x27;div3&#x27; onClick={this.clickHandler3.bind(this)} a={1}&gt;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            this is Header</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        &lt;/div&gt;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    &lt;/div&gt;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;/div&gt;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>合成事件上的<code>_dispatchListeners</code>与<code>_dispatchInstances</code>上分别为：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">_dispatchListener = [</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    clickHandler1,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    clickHandler2,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    clickHandler3</span></span><span class="token-line" style="color:#393A34"><span class="token plain">]</span></span><span class="token-line" style="color:#393A34"><span class="token plain">_dispatchInstances = [</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    id为&#x27;div1&#x27;的fiberNode,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    id为&#x27;div2&#x27;的fiberNode,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   id为&#x27;div3&#x27;的fiberNode</span></span><span class="token-line" style="color:#393A34"><span class="token plain">]</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="执行合成事件对象上的事件处理函数"></a>执行合成事件对象上的事件处理函数<a class="hash-link" href="#执行合成事件对象上的事件处理函数" title="Direct link to heading">#</a></h2><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">runExtractedEventsInBatch 执行合成事件对象上的事件处理函数的逻辑：</span></span><span class="token-line" style="color:#393A34"><span class="token plain">runEventsInBatch(events);</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>触发过程的函数调用栈如下：</p><p><img src="/ReactNote/assets/images/2-3-26efebd14611b61f3613808f0e84486f.png">
经过上述的逻辑之后，会从头到尾的调用合成事件对象上<code>_dispatchListeners</code>上的事件处理函数。到此本文重点在弄清楚了合成事件对象和原生事件对象的关系，以及如何收集<code>fiber</code>树上的事件处理函数。至于如何执行，是明天研究的内容了。当然还是接着这个写吧。
从<code>runEventsInBatch</code>开始，最后调用合成事件上的事件处理函数：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">//将新的合成事件对象添加到原来的对象队列中，然后进入下一个处理环节forEachAccumulated</span></span><span class="token-line" style="color:#393A34"><span class="token plain">export function runEventsInBatch(events) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  if (events !== null) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 将当前生成的合成事件对象或者合成事件对象数组添加到之前的合成事件对象队列中，构成新的队列</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    eventQueue = accumulateInto(eventQueue, events);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  //  将新的合成事件对象队列eventQueue作为正在处理的队列processingEventQueue，并将前者清空</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  const processingEventQueue = eventQueue;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  eventQueue = null;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  if (!processingEventQueue) {return;}</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  //进入下一步</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseTopLevel);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p><code>runEventsInBatch</code>将<strong>新的合成事件对象合并到原来的对象队列</strong>中，然后进入下一个处理环节<code>forEachAccumulated</code>，可见<code>react</code>的每个函数的缜密，每一步都添加了对应的错误处理机制。<code>forEachAccumulated</code>函数源码：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">function forEachAccumulated(arr,cb,scope,) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  if (Array.isArray(arr)) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    arr.forEach(cb, scope);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  } else if (arr) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    cb.call(scope, arr);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p><code>forEachAccumulated</code>会对传入的<code>arr</code>数组的元素挨个执行<code>cb(arr[i])</code>，这里的<code>cb</code>为上一步中传入的<code>executeDispatchesAndReleaseTopLevel</code>，<code>arr``为processingEventQueue</code>。<code>arr</code>如果不是数组直接执行<code>cb(arr)</code> ，因此主要看executeDispatchesAndReleaseTopLevel的逻辑：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">const executeDispatchesAndReleaseTopLevel = function(e) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  return executeDispatchesAndRelease(e);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span></span><span class="token-line" style="color:#393A34"><span class="token plain">const executeDispatchesAndRelease = function(event: ReactSyntheticEvent) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  if (event) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    executeDispatchesInOrder(event);</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!event.isPersistent()) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      event.constructor.release(event);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>先看第二步：这里先看<code>if</code>中的<code>if</code>，如果合成事件对象的状态不是 <code>isPersistent</code> 即 <code>event.isPersistent</code>返回的始终是<code>false</code>，那么这里始终会执行<code>release</code>重置<code>event</code>上的属性值，并添加到事件对象池的空余位置，重置合成事件对象的代码如下：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">react\packages\events\SyntheticEvent.js</span></span><span class="token-line" style="color:#393A34"><span class="token plain">//重置event上的属性值，并添加到事件对象池的空余位置</span></span><span class="token-line" style="color:#393A34"><span class="token plain">function releasePooledEvent(event) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  const EventConstructor = this;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  //</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  event.destructor();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  if (EventConstructor.eventPool.length &lt; EVENT_POOL_SIZE) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    EventConstructor.eventPool.push(event);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain">//合成事件对象实例重置</span></span><span class="token-line" style="color:#393A34"><span class="token plain">destructor: function() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    const Interface = this.constructor.Interface;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (const propName in Interface) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        this[propName] = null;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.dispatchConfig = null;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    this._targetInst = null;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.nativeEvent = null;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.isDefaultPrevented = functionThatReturnsFalse;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.isPropagationStopped = functionThatReturnsFalse;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    this._dispatchListeners = null;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    this._dispatchInstances = null;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">});</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><blockquote><p>这里涉及一个实际开发中的一个关键问题，为什么涉及到异步函数中需要用到 <code>event.persist()</code> ？</p></blockquote><p>在上一个 <code>if</code> 块中会执行 <code>executeDispatchesInOrder(event)</code> 来依次执行事件处理函数，并且共用一个 <code>event</code>（因此只要有一个事件处理函数调用了<code>persist</code>，那么其他的函数的异步代码都能访问到有效的合成事件对象），等所有事件处理函数的同步代码执行完成之后，如果所有处理函数都没调用合成事件对象的<code>persist</code>函数， 那么就会重置这个合成事件对象上的属性值，并将空的合成事件对象添加到事件池中（如果池子满了，无需添加最终会被自动 <code>GC</code>）。这里调用 <code>event.persist</code> 会改变 <code>event</code> 的状态为 <code>isPersistent</code>，能够避免所有事件处理函数执行完之后合成事件对象被重置。</p><p>接着看关键的第一步，<code>executeDispatchesInOrder</code>是如何执行合成事件对象上的事件处理函数的：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">export function executeDispatchesInOrder(event) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  const dispatchListeners = event._dispatchListeners;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  const dispatchInstances = event._dispatchInstances;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  if (Array.isArray(dispatchListeners)) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (let i = 0; i &lt; dispatchListeners.length; i++) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      if (event.isPropagationStopped()) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        break;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      // Listeners and Instances are two parallel arrays that are always in sync.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      executeDispatch(event, dispatchListeners[i], dispatchInstances[i]);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  } else if (dispatchListeners) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    executeDispatch(event, dispatchListeners, dispatchInstances);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  event._dispatchListeners = null;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  event._dispatchInstances = null;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>从上面代码的循环可以看到，遍历<code>event._dispatchListeners</code>上的监听器，首先通过合成事件对象上的<code>isPropagationStopped()</code>来判断是否阻止捕获和冒泡阶段中当前事件的进一步传播，如果有则往后的事件处理函数都无法被执行。如果没有阻止传播，那么会调用 <code>executeDispatch</code>执行事件处理函数，最终将合成事件对象上的<code>_dispatchListeners</code>与<code>_dispatchInstances</code>清空。现在来看<code>executeDispatch</code>：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">function executeDispatch(event, listener, inst) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  const type = event.type || &#x27;unknown-event&#x27;;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  //获取当前fiber对应的真实DOM</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  event.currentTarget = getNodeFromInstance(inst);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  //进入下一步</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  invokeGuardedCallbackAndCatchFirstError(type, listener, undefined, event);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  event.currentTarget = null;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p><code>executeDispatch</code>会将当前传入的这个<code>fiber</code>的真实DOM存储在合成事件对象上的<code>currentTarget</code>属性上，然后将合成事件对象与当前fiber对应的事件处理函数一起传入<code>invokeGuardedCallbackAndCatchFirstError</code>：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">react\packages\shared\ReactErrorUtils.js</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">function invokeGuardedCallbackAndCatchFirstError(name,func,context,a,b,c,d,e,f) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  invokeGuardedCallback.apply(this, arguments);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain">export function invokeGuardedCallback(name,func,context,a,b,c,d,e,f) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  invokeGuardedCallbackImpl.apply(reporter, arguments);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain">//在开发环境下invokeGuardedCallbackImpl = invokeGuardedCallbackDev;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">//invokeGuardedCallbackDev中涉及到如何处理错误，保证了系统的健壮性——TODO</span></span><span class="token-line" style="color:#393A34"><span class="token plain">//react\packages\shared\invokeGuardedCallbackImpl.js</span></span><span class="token-line" style="color:#393A34"><span class="token plain">let invokeGuardedCallbackImpl = function(name,func,context,a,b,c,d,e,f){</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  const funcArgs = Array.prototype.slice.call(arguments, 3);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  try {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    func.apply(context, funcArgs);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  } catch (error) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.onError(error);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p> 最终通过<code>invokeGuardedCallbackImpl</code>中调用<code>func.apply(context, funcArgs)</code>，执行事件处理函数。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="总结"></a>总结<a class="hash-link" href="#总结" title="Direct link to heading">#</a></h2><ol><li><p>合成事件对象的初始化</p></li><li><p>在<code>fiber</code>树上模拟捕获与冒泡事件，即先模拟捕获阶段，从远古祖先节点<code>document</code>开始向事件触发的目标节点遍历，遍历的过程搜集需要在捕获阶段触发的事件处理函数以及对应的节点并存入合成事件对象的相关属性；然后模拟冒泡阶段，从事件触发的目标节点开始向远古祖先节点<code>document</code>开始遍历，遍历的过程搜集需要在冒泡阶段触发的事件处理函数以及对应的节点并存入之前存储了捕获阶段的函数与节点的相关属性的数组中；在两个遍历之初会遍历一遍事件目标节点以上的树并以此存入一个数组中，然后捕获和冒泡都是遍历这个数组。</p></li><li><p>将新的合成事件对象添加到已有的事件对象队列中，然后开始依次执行队列中每个合成事件对象上存储的事件处理函数数组。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="彩蛋bind"></a>彩蛋bind<a class="hash-link" href="#彩蛋bind" title="Direct link to heading">#</a></h2></li></ol><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_31ik" id="改装事件监听器函数"></a>改装事件监听器函数：<a class="hash-link" href="#改装事件监听器函数" title="Direct link to heading">#</a></h4><p>通过<code>addEventListener</code>添加的事件处理函数只有一个输入参数为<code>event</code>事件。
如下:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">element.addEventListener(eventType, listener, true);</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>现在的需求是：
当事件触发的时候，想调用下面这个函数</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">function dispatchInteractiveEvent(type, event) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    ...</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><blockquote><p>最容易想到的方法是：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">const listener = function(event){</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 一些和type变量有关的逻辑</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        ...</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    dispatchInteractiveEvent(type, event)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain">element.addEventListener(eventType, listener, true);</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div></blockquote><blockquote><p>利用bind实现：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">// 一些和type变量有关的逻辑</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    ...</span></span><span class="token-line" style="color:#393A34"><span class="token plain">const listener = dispatchInteractiveEvent.bind(null, type);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">element.addEventListener(eventType, listener, true);</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div></blockquote><blockquote><p>这两者的区别：</p></blockquote><p><code>bind</code>实现可以将<code>type</code>的逻辑放到外层作用域，并且在事件触发之前<code>type</code>就计算好了。而第一种方法事件触发调用回调的时候才计算<code>type</code>，这个时候必然造成内存泄漏，因为<code>type</code>的逻辑可能涉及到外层作用域的局部变量。<code>bind</code>实现，<code>type</code>已经计算好了，所以垃圾回收机制会自动回收不用的变量。</p><p>总的一句话就是：第一种造成了闭包的效果。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="彩蛋apply巧妙拼接两个数组"></a>彩蛋apply巧妙拼接两个数组<a class="hash-link" href="#彩蛋apply巧妙拼接两个数组" title="Direct link to heading">#</a></h2><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_31ik" id="利用apply将数组b添加到数组a后面"></a>利用<code>apply</code>将数组b添加到数组a后面<a class="hash-link" href="#利用apply将数组b添加到数组a后面" title="Direct link to heading">#</a></h4><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">var a=[1,2]，b=[3,4]</span></span><span class="token-line" style="color:#393A34"><span class="token plain">a.push.apply(a,b) // 返回数组a的长度</span></span><span class="token-line" style="color:#393A34"><span class="token plain">a // [1, 2, 3, 4]</span></span><span class="token-line" style="color:#393A34"><span class="token plain">b // [3, 4]</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p><code>apply</code>在这里主要的作用是可以将数组作为参数传入，然后一个一个对数组中的元素执行<code>a.push(b[i])</code>,这里this必须指向<code>a</code>。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_31ik" id="与concat的不同"></a>与concat的不同<a class="hash-link" href="#与concat的不同" title="Direct link to heading">#</a></h4><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">var a=[1,2]，b=[3,4]</span></span><span class="token-line" style="color:#393A34"><span class="token plain">a.concat(b) // 返回新的数组，由a与b数组组成</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_31ik" id="总结-1"></a>总结<a class="hash-link" href="#总结-1" title="Direct link to heading">#</a></h4><p>这里<code>apply</code>可以节省内存，不需要创建新的数组。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_31ik" id="来源react源码的accumulateinto函数"></a>来源react源码的accumulateInto函数<a class="hash-link" href="#来源react源码的accumulateinto函数" title="Direct link to heading">#</a></h4><p>该函数保持传入的第二个参数不发生改变</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">function accumulateInto(</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  current,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  next,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  if (current == null) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return next;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  if (Array.isArray(current)) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (Array.isArray(next)) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      current.push.apply(current, next);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      return current;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    current.push(next);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return current;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  if (Array.isArray(next)) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return [current].concat(next);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  return [current, next];</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/BUPTlhuanyu/ReactNote/tree/master/docs/react/react/event/react事件系统之事件触发.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_2_ui" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_13-_"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/ReactNote/docs/react/react/event/event-bind"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« 事件绑定</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/ReactNote/docs/react/react/error/error-handle"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">如何处理错误 »</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_35-E thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#概述背景" class="table-of-contents__link">概述，背景</a></li><li><a href="#合成事件对象" class="table-of-contents__link">合成事件对象</a></li><li><a href="#执行合成事件对象上的事件处理函数" class="table-of-contents__link">执行合成事件对象上的事件处理函数</a></li><li><a href="#总结" class="table-of-contents__link">总结</a></li><li><a href="#彩蛋apply巧妙拼接两个数组" class="table-of-contents__link">彩蛋apply巧妙拼接两个数组</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2021 BUPTlhuanyu, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/ReactNote/assets/js/runtime~main.f75cb977.js"></script>
<script src="/ReactNote/assets/js/main.af5c24bf.js"></script>
</body>
</html>